## Web cache deception
Web cache deception is a vulnerability that enables an attacker to trick a web cache into storing sensitive, dynamic content. It's caused by discrepancies between how the cache server and origin server handle requests. 
- `Web cache poisoning` manipulates cache keys to inject malicious content into a cached response, which is then served to other users.
- `Web cache deception` exploits cache rules to trick the cache into storing sensitive or private content, which the attacker can then access.

Research: https://portswigger.net/research/gotta-cache-em-all


Black Hat USA 2024 : https://youtu.be/70yyOMFylUA?si=28MYiu8lpoQfzhrS

## Cache rules
- Static file extension rules - These rules match the file extension of the requested resource,
  - .css, .js.
- Static directory rules - These rules match all URL paths that start with a specific prefix. These are often used to target specific directories that contain only static resources,
  - /static, /assets, /wp-content, /media, /templates, /public, /shared
- File name rules - These rules match specific file names to target files that are universally required for web operations and change rarely,
  - such as robots.txt and favicon.ico.

## Detecting cached responses
- X-Cache header provides information about whether a response was served from the cache. Typical values include:
  - X-Cache: hit - The response was served from the cache.
  - X-Cache: miss - The cache did not contain a response for the request's key, so it was fetched from the origin server. In most cases, the response is then cached. To confirm this, send the request again to see whether the value updates to hit.
  - X-Cache: dynamic - The origin server dynamically generated the content. Generally this means the response is not suitable for caching.
  - X-Cache: refresh - The cached content was outdated and needed to be refreshed or revalidated.
- [Cache-Control](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Cache-Control) header may include a directive that indicates caching, like public with a max-age higher than 0. This only suggests that the resource is cacheable. It isn't always indicative of caching, as the cache may sometimes override this header.

# Exploiting Cache Deception
Identify a discrepancy in how the cache and origin server parse the URL path. This could be a discrepancy in how they:
- Map URLs to resources.
  - Path Params `/MyAccount/param1`
- Process delimiter characters.
  - [delimiter-list](https://portswigger.net/web-security/web-cache-deception/wcd-lab-delimiter-list)
```
!
"
#
$
%
&
'
(
)
*
+
,
-
.
/
:
;
<
=
>
?
@
[
\
]
^
_
`
{
|
}
~
%21
%22
%23
%24
%25
%26
%27
%28
%29
%2A
%2B
%2C
%2D
%2E
%2F
%3A
%3B
%3C
%3D
%3E
%3F
%40
%5B
%5C
%5D
%5E
%5F
%60
%7B
%7C
%7D
%7E
```
- Normalize paths.
  - `/static/..%2fprofile` => `/static` 

## Exploiting static extension cache rules
Cache rules often target static resources by matching common file extensions like `.css` or `.js` . This is the default behavior in most CDNs. 
### 1) Path mapping discrepancies
`http://example.com/path/resource/param1/param2` => `http://example.com/user/123/profile/wcd.css`
### 2) Delimiter discrepancies
1) Test the endpoint `/settings/users/list` => `/settings/users/listaaa`, you'll use this response as a reference when you start testing delimiter characters.
> Note: If the response is identical to the original response, this indicates that the request is being redirected. You'll need to choose a different endpoint to test. 
2) Test `settings/users/list;aaa`, or any other delimiter
    - If the response is identical to the base response, this indicates that the `;` character is used as a delimiter and the origin server interprets the path as /settings/users/list.✅
    - If it matches the response to the path with the arbitrary string, this indicates that the `;` character isn't used as a delimiter and the origin server interprets the path as `/settings/users/list;aaa`. ❌
> Note: Some delimiter characters may be processed by the victim's browser before it forwards the request to the cache. This means that some delimiters can't be used in an exploit. For example, browsers URL-encode characters like {, }, <, and >, and use # to truncate the path. If the cache or origin server decodes these characters, it may be possible to use an encoded version in an exploit.

### 3) Delimiter Decoding Discrepancies
1) Use the same testing methodology you used to identify and exploit delimiter discrepancies, but use a range of encoded characters.
2) Make sure that you also test encoded non-printable characters, particularly `%00`, `%0A` and `%09`. If these characters are decoded they can also truncate the URL path. 


Differences in which delimiter characters are decoded by the cache and origin server can result in discrepancies in how they interpret the URL path, even if they both use the same characters as delimiters. Consider the example `/profile%23wcd.css`, which uses the URL-encoded `#` character
- The origin server decodes `%23` to `#`. It uses `#` as a delimiter, so it interprets the path as /profile and returns profile information.
- The cache also uses the `#` character as a delimiter, but doesn't decode `%23`. It interprets the path as `/profile%23wcd.css`. If there is a cache rule for the `.css extension` it will store the response.


Some cache servers may **decode the URL and then forward the request** with the decoded characters. Others first apply **cache rules based on the encoded URL, then decode the URL and forward** it to the next server. Consider the example `/myaccount%3fwcd.css`. 

- The cache server applies the cache rules based on the encoded path `/myaccount%3fwcd.css` and decides to store the response as there is a cache rule for the `.css` extension. It then decodes `%3f` to `?` and forwards the rewritten request to the origin server.
- The origin server receives the request `/myaccount?wcd.css`. It uses the `?` character as a delimiter, so it interprets the path as `/myaccount`.


## Exploiting static directory cache rules
### 1) Normalization by the origin server
send a request to a non-cacheable resource with a path traversal sequence and an arbitrary directory at the start of the path, To choose a non-cacheable resource, look for a non-idempotent method like POST. For example, modify `/profile` to `/aaa/..%2fprofile`:
- If the response matches the base response and returns the profile information, this indicates that the path has been interpreted as /profile. The origin server decodes the slash and resolves the dot-segment.✅
- If the response doesn't match the base response, for example returning a 404 error message, this indicates that the path has been interpreted as `/aaa/..%2fprofile`. The origin server either doesn't decode the slash or resolve the dot-segment. ❌

> Note: When testing for normalization, start by encoding only the second slash in the dot-segment. This is important because some CDNs match the slash following the static directory prefix.

#### Explloit Scheme
```
GET /<Dynamic_Resource><Delimiter><Encoded_Dot_Segment><Static_Directory>
```


> Note: You can also try encoding the full path traversal sequence, or encoding a dot instead of the slash. This can sometimes impact whether the parser decodes the sequence.
### 2) Normalization by the cache server
Choose a request with a response that contains evidence of being cached. For example, `/aaa/..%2fassets/js/stockCheck.js`:
- If the response is no longer cached, this indicates that the cache isn't normalizing the path before mapping it to the endpoint. It shows that there is a cache rule based on the `/assets` prefix. 
- If the response is still cached, this may indicate that the cache has normalized the path to `/assets/js/stockCheck.js`. 


You can also add a path traversal sequence after the directory prefix. For example, modify `/assets/js/stockCheck.js` to `/assets/..%2fjs/stockCheck.js`:
- If the response is no longer cached, this indicates that the cache decodes the slash and resolves the dot-segment during normalization, interpreting the path as `/js/stockCheck.js`. It shows that there is a cache rule based on the `/assets` prefix. 
- If the response is still cached, this may indicate that the cache hasn't decoded the slash or resolved the dot-segment, interpreting the path as `/assets/..%2fjs/stockCheck.js`

### 3) Delimiters Discrepancies
If a character is used as a delimiter by the origin server but not by the cache and the cache normalizes the path before applying a static directory rule, you can hide a path traversal segment after the delimiter, which the cache will resolve:
```
GET /<Dynamic_Resource><Delimiter><Encoded_Dot_Segment><Static_Directory>
```
It's important to encode the dot-segment. Otherwise the victim’s browser will resolve it and won't forward the original malicious path.




