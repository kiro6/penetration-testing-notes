# Content
- [Install Burp's Cert](#install-burps-cert)
    - [As System Cert](#as-system-cert)
    - [As User Cert](#as-user-cert)  
- [SSL pinning](#ssl-pinning)
    - [Patching Fingerprint](#patching-fingerprint)
    - [Patching Certificate](#patching-certificate)     

# Install Burp's Cert 
## As System Cert
> Note: Device must be rooted 
1) stat emulator
```
emulator.exe -avd "Pixel" -writable-system
```
2) export burp's cert in der format
3) make burp's cert in good format
```shell
# linux shell
openssl x509 -inform DER -in burpCa.der -out burpCa.pem
CERTHASHNAME="`openssl x509 -inform PEM -subject_hash_old -in burpCa.pem | head -1`.0"
cp burp_cacert.pem $CERTHASHNAME
# should look like this 9a5ba575.0
```
4) conf adb
```
adb root
adb remount 
```
5) inject the cert as system cert
```powershell
# adb shell

# inject cert as system's cert
mkdir -p -m 700 /data/local/tmp/tmp-ca-copy

# Copy out the existing certificates
cp /apex/com.android.conscrypt/cacerts/* /data/local/tmp/tmp-ca-copy/

# Create the in-memory mount on top of the system certs folder
mount -t tmpfs tmpfs /system/etc/security/cacerts

# Copy the existing certs back into the tmpfs, so we keep trusting them
mv /data/local/tmp/tmp-ca-copy/* /system/etc/security/cacerts/

# Copy our new cert in, so we trust that too
mv /sdcard/9a5ba575.0 /system/etc/security/cacerts/

# Update the perms & selinux context labels
chown root:root /system/etc/security/cacerts/*
chmod 644 /system/etc/security/cacerts/*
chcon u:object_r:system_file:s0 /system/etc/security/cacerts/*

# Deal with the APEX overrides, which need injecting into each namespace:

# First we get the Zygote process(es), which launch each app
ZYGOTE_PID=$(pidof zygote || true)
ZYGOTE64_PID=$(pidof zygote64 || true)
# N.b. some devices appear to have both!

# Apps inherit the Zygote's mounts at startup, so we inject here to ensure
# all newly started apps will see these certs straight away:
for Z_PID in "$ZYGOTE_PID" "$ZYGOTE64_PID"; do
    if [ -n "$Z_PID" ]; then
        nsenter --mount=/proc/$Z_PID/ns/mnt -- \
            /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
    fi
done

# Then we inject the mount into all already running apps, so they
# too see these CA certs immediately:

# Get the PID of every process whose parent is one of the Zygotes:
APP_PIDS=$(
    echo "$ZYGOTE_PID $ZYGOTE64_PID" | \
    xargs -n1 ps -o 'PID' -P | \
    grep -v PID
)

# Inject into the mount namespace of each of those apps:
for PID in $APP_PIDS; do
    nsenter --mount=/proc/$PID/ns/mnt -- \
        /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts &
done
wait # Launched in parallel - wait for completion here

echo "System certificate injected"


```
## As User Cert
1) export burp's cert in der format
2) move cert to sdcard
```
adb push .\burpCa.der /sdcard/
```
3) open `Encryption & Credentials` then `Install Certificate` then select burp's cert

![cert](https://github.com/user-attachments/assets/d61b168c-2061-41b2-82be-0c14c6b1c292)


# SSL pinning
## Patching Fingerprint
this when developer use the fingerprint of the `public key` or the `certificate` for ssl pinning

### how to find ?
there is 2 approaches the `network_security_config` and code checks
#### 1) network_security_config
- androidmanifest.xml you can find `network_security_config`
```xml
android:networkSecurityConfig="@xml/network_security_config"
```
- network_security_config.xml you can find the fingerprint
```xml
<?xml version="1.0" encoding="utf-8"?>
<network-security-config>
    <domain-config>
        <domain includeSubdomains="true">example.com</domain>
        <pin-set>
            <pin digest="SHA-256">zKePnjF2yATEC6NGgoKvBjb5NkyDDN3mPGtRspV6vBc=
            </pin>
        </pin-set>
    </domain-config>
</network-security-config>
```
#### 2) code check 
- this is example of using `Okhttp3` library to check the fingerprint 
```java
CertificatePinner certificatePinner = new CertificatePinner.Builder().add("example.com", "sha256/zKePnjF2yATEC6NGgoKvBjb5NkyDDN3mPGtRspV6vBc=").build();
OkHttpClient client = new OkHttpClient.Builder().certificatePinner(certificatePinner).build();
Request request = new Request.Builder().url("https://example.com").build();
```

### SSL pinning bypass
> Note: need to add your burp cert to the mobile phone first check [Install Burp's Cert](#install-burps-cert)
#### prepare your burp's fingerprint
```shell
# linux shell
## convert burp der to pen format
openssl x509 -inform der -in burp.der -pubkey -noout -out burp_pub_key.pem
## get the hash (fingerprint) of the public key
openssl rsa -pubin -in burp_pub_key.pem -outform der | openssl dgst -sha256 -binary | openssl enc -base64
```
### decompile using apktool
```powershell
apktool d app.apk
```
### change the values 
- for network_security_config also check [security-config - base-config](https://developer.android.com/privacy-and-security/security-config#base-config)
```xml
<base-config cleartextTrafficPermitted="true">
    <trust-anchors>
        <certificates src="system" />
        <certificates src="user" />
    </trust-anchors>
</base-config>
```
-  for code checks open smali code then change the fingerprint values
```smali
const-string v2, "sha256/szMxWlylZsaW+UNyT9n8UOfgTPsZikdw1e6SwKwuDWk="
```

### sign the app

```powershell
# build the app
apktool b app\

# create sign key (can be found in "Android Studio\jbr\bin\keytool.exe" )
keytool -genkey -v -keystore your-keystore.jks -keyalg RSA -keysize 2048 -validity 10000 -alias <key alias name>

# align the app (can be found in build-tools)
zipalign -v 4 <your_app.apk> <your_app_aligned.apk>

# sign the key (can be found in build-tools )
apksigner.bat sign --ks your-keystore.jks --ks-key-alias <key alias name> --out <signed_apk.apk> <not_signed_apk.apk>
```

## Patching Certificate
this when the developer use the `certificate itself` for ssl pinning

### how to find ?
there is 2 approaches the `network_security_config` and code checks
#### 1) network_security_config
- androidmanifest.xml you can find `network_security_config`
```xml
android:networkSecurityConfig="@xml/network_security_config"
```
- network_security_config.xml you can find the cert location 
```xml
<?xml version="1.0" encoding="utf-8"?>
<network-security-config>
    <base-config>
        <trust-anchors>
            <certificates src="@raw/server" />
        </trust-anchors>
    </base-config>
</network-security-config>
```
#### 2) code check 
this example of using the `X509TrustManager` to check the cert
```java
private InputStream trustedCertificatesInputStream() {
    // Return an InputStream for the trusted certificates from raw resources
    return this.context.getResources().openRawResource(R.raw.server);
}

private X509TrustManager trustManagerForCertificates(InputStream in) throws GeneralSecurityException {
    // Create a CertificateFactory for X.509 certificates
    CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
    
    // Generate certificates from the provided InputStream
    Collection<? extends Certificate> certificates = certificateFactory.generateCertificates(in);
    
    // Ensure at least one certificate is available
    if (certificates.isEmpty()) {
        throw new IllegalArgumentException("expected non-empty set of trusted certificates");
    }
    
    char[] password = "password".toCharArray(); // Password for the KeyStore
    KeyStore keyStore = newEmptyKeyStore(password); // Create an empty KeyStore
    
    int index = 0; // Index for certificate aliases
    for (Certificate certificate : certificates) {
        // Store each certificate in the KeyStore with a unique alias
        keyStore.setCertificateEntry(Integer.toString(index++), certificate);
    }
    
    // Initialize KeyManagerFactory with the KeyStore
    KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
    keyManagerFactory.init(keyStore, password);
    
    // Initialize TrustManagerFactory with the KeyStore
    TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
    trustManagerFactory.init(keyStore);
    
    // Retrieve the TrustManagers from the factory
    TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
    
    // Ensure there is exactly one X509TrustManager
    if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
        throw new IllegalStateException("Unexpected default trust managers:" + Arrays.toString(trustManagers));
    }
    
    return (X509TrustManager) trustManagers[0]; // Return the X509TrustManager
}

```
