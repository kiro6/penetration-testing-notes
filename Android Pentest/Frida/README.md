# Content
- [Setup frida](#setup-frida)
- [Frida Commands](#frida-commands)
- [Scritping](#scritping)
    - [Hooking Function](#hooking-function)
    - [Hooking Constructor](#hooking-constructor)
    - [Calling Methods](#calling-methods)
    - [Working with Instances](#working-with-instances)     

# Setup frida 
```powershell
pip install frida-tools # CLI tools
pip install frida       # Python bindings
npm install frida       # Node.js bindings
# this for autocomplete
npm install @types/frida-gum


# add frida server
adb push frida-server /data/local/tmp/
```

# Frida Commands
```powershell
# start a app with frida attached to it
frida -U -f com.example.appname -l your_script.js

# attach frida to runing app
frida -U -n com.example.appname -l your_script.js
## using pid
frida -U -p <PID> -l your_script.js

# find runing process 
frida-ps.exe -U  | Select-String "Appname"

```

# Scritping

## Hooking Function
### basic
```js
Java.perform(function () {
    console.log("loading script");
//class name: Dicer
    var Dicer = Java.use("org.secuso.privacyfriendlydicer.dicer.Dicer");
//func name: rollDice
    Dicer.rollDice.implementation = function (param1, param2) {
        console.log("hooking the dice");
        send("value of param1: " + param1+" | value of param2: "+param2);

        return [20, 20, 20, 20, 20, 20, 101];
    }
    console.log("script loading done");
});
```
### diff implementation in a case otherwise return orginal function
```js
Java.perform(function () {
    // Hook into MainActivity's onClick method where the password is checked
    // Override the equals method that compares the hash with the hardcoded hash
    var StringClass = Java.use('java.lang.String');
    StringClass.equals.implementation = function (other) {
        // Log the comparison details
        // console.log("[*] Comparing string with: " + other);

        // If the hash being compared is the one for the password check, bypass it
        if (other == "735c3628699822c4c1c09219f317a8e9") {
            console.log("[*] Bypassing password check!");
            return true;  // Always return true to bypass the password check
        }

        // For all other cases, use the original equals method
        return this.equals(other);
    };
}
```

### Overloading 

```javascript
Java.perform(function() {
    var YourClass = Java.use("com.example.YourClass");
    
    // For a function with different parameter types
    YourClass.targetFunction.overload('int').implementation = function(x) {
        // Handles function with int parameter
        console.log("Called with int: " + x);
        return this.targetFunction(x);
    }

    YourClass.targetFunction.overload('java.lang.String').implementation = function(s) {
        // Handles function with String parameter
        console.log("Called with string: " + s);
        return this.targetFunction(s);
    }

    // For multiple parameters
    YourClass.targetFunction.overload('int', 'java.lang.String').implementation = function(x, s) {
        // Handles function with int and String parameters
        console.log("Called with int and string: " + x + ", " + s);
        return this.targetFunction(x, s);
    }
});
```

- Finding all overloads:

```javascript
Java.perform(function() {
    var YourClass = Java.use("com.example.YourClass");
    
    // List all overloads
    YourClass.targetFunction.overloads.forEach(function(overload) {
        overload.implementation = function() {
            console.log("Called with args:", arguments);
            // Call original with same arguments
            return overload.apply(this, arguments);
        };
    });
});
```

#### Common Java type references
- 'int': Integer
- 'boolean': Boolean
- '[B': byte array
- 'java.lang.String': String
- '[I': int array
- 'void': void return type
- 'java.lang.Object': Object
- 'double': Double
- 'float': Float

## Hooking Constructor

```js
Java.perform(()=>{
    console.log("loading script");
    
    var DicerViewModel = Java.use('org.secuso.privacyfriendlydicer.ui.DicerViewModel');

    // Hook the constructor to access or modify the values after object creation
    DicerViewModel.$init.overload().implementation = function () {
        // Call the original constructor to ensure that any initialization done by the original constructor still occurs.
        var instance = this.$init();

        // Modify faceNumber and diceNumber values
        console.log("Original faceNumber: " + this.faceNumber.value);
        console.log("Original diceNumber: " + this.diceNumber.value);

        // Change the values
        this.faceNumber.value = 6;  // Change faceNumber to 10
        this.diceNumber.value = 6;   // Change diceNumber to 2

        console.log("Modified faceNumber: " + this.faceNumber.value);
        console.log("Modified diceNumber: " + this.diceNumber.value);

        return instance;
    };
}
```

## Calling Methods
> This will call the method for a new created Instance of a class 
```js
Java.perform(function() {
    // Use the Random class
    const Random = Java.use('java.util.Random');
    
    // Create an instance of Random
    const randomInstance = Random.$new();
    
    // Generate a random integer between 0 and 100
    var randomValue = randomInstance.nextInt(101); // 101 is exclusive, so it generates 0 to 100
    
    // Send the generated random value to the Frida console
    send("Random.nextInt: " + randomValue);
});

```

## Working with Instances
> this will work on already exisnts instances of classes


###  edit property
```js
Java.perform(function () {
    // Use Java.choose to find instances of the specified class
    Java.choose("de.fgerbig.spacepeng.services.Profile", {
        onMatch: function(instance) {
            // This function is called for each found instance of the class
            send('Found: ' + instance);
            
            // Modify the highScore property of the instance
            instance.highScore.value = 1000000;

            send('Modified highScore: ' + instance.highScore.value);
        },
        onComplete: function() {
            // This function is called when all instances have been processed
            send('All instances processed');
        }
    });
});
```
### edit function
```js
Java.perform(function () {
    // Use Java.choose to find instances of the Game class
    Java.choose("com.example.Game", {
        onMatch: function(instance) {
            // Hook the getScore method
            const getScoreMethod = instance.getScore;

            instance.getScore.implementation = function() {
                // Call the original method (if needed)
                var originalScore = getScoreMethod.call(this);
                
                // Modify the score before returning
                var modifiedScore = originalScore + 1000; // Increase score by 1000

                // Log the original and modified score
                send('Original score: ' + originalScore + ', Modified score: ' + modifiedScore);
                
                return modifiedScore; // Return the modified score
            };

            send('Hooked getScore for instance: ' + instance);
        },
        onComplete: function() {
            send('All instances processed');
        }
    });
});

```

## Hooking NDK
Consider this function
```java
 public native String decryptString(String str, int i);

    static {
        System.loadLibrary("native-lib");
    }


```

#### Using Address Pointers
```javascript
// Address of the function we want to hook
var decryptStringAddress = 0x0;
 
// Getting all exports out of the libnative-lib.so
var exportedFunctions = Module.enumerateExports("libnative-lib.so")
 
// Iterating over this array trying to find decryptString
exportedFunctions.forEach(function(element, index){
 
    // finding the function that contains decryptString
    if(element.name.includes('decryptString')) {
 
        console.log("Name = " + element.name);
        console.log("Pointer = " + element.address);

        // Getting the address of this function
        decryptStringAddress = element.address;
    }
})
 
Interceptor.attach(decryptStringAddress, {
 
    onEnter: function(args) {
        
        // Getting the string-class reference for the type cast
        var stringClassRef = Java.use('java.lang.String');
        // Typecasting the argument 2 to a Java - String
        var stringInstance = Java.cast(ptr(args[2]), stringClassRef);
 
        send("We are in decryptString");
        send("First parameter = " + stringInstance);
        send("Second parameter = " + args[3].toInt32());
    },
    onLeave: function(ret) {

        // Leaving the function
        send("Return value = " + ret);
        send("We are leaving the decryptString function right now");
    }
})

```

- **manpluate args**

```javascript
// Address of the function we want to hook
var decryptStringAddress = 0x0;
 
// Getting all exports out of the libnative-lib.so
Module
var exportedFunctions = Module.enumerateExports("libnative-lib.so")
 
// Iterating over this array trying to find decryptString
exportedFunctions.forEach(function(element, index){
 
    // finding the function that contains decryptString
    if(element.name.includes('decryptString')) {
 
        console.log("Name = " + element.name);
        console.log("Pointer = " + element.address);

        // Getting the address of this function
        decryptStringAddress = element.address;
    }
})
 
Interceptor.attach(decryptStringAddress, {
 
    onEnter: function(args) {


        console.log("Entering decrypt function")
        // overwriting the string argument
        args[2] = Java.vm.getEnv().newStringUtf("overwriting the argument");
        
        // overwriting the integer argument 
        args[3] = ptr(0);


    },
    onLeave: function(ret) {

        // overwriting the return value
        var returnValue = Java.vm.getEnv().newStringUtf("overwriting the argument the return value");
        ret.replace(returnValue);

        console.log("Leaving decrypt function");
    }
})
```

#### Using Java Prototype
```javascript
Java.perform(function() {

    // Class reference of the Mainactivity
    var mainActivity = Java.use('com.apphacking.ndkfrida.MainActivity');
    mainActivity.decryptString.implementation = function(param1, param2) {

        send("Param 1 = " + param1);
        send("Param 2 = " + param2);

        // return value
        var returnValue = this.decryptString(param1, 13);

        send("Return value = " + returnValue);

        return returnValue;


    }

})
```
## Hooking Native C Function
#### using conditional branch
```javascript
var addressOfStrcmp;

// Get the address of the strcmp function
var importFunctionArray = Module.enumerateImports("libnative-lib.so");

importFunctionArray.forEach(function(element) {

    if (element.name.includes("strcmp")) {
        console.log(element.name);
        console.log(element.address);

        addressOfStrcmp = element.address;
    }

})

// introducing a new state to only print out the return value of our strcmp
var isOurFunction = false;

// Interceptor.attach(address, callbacks)
Interceptor.attach(addressOfStrcmp, {
    
    // args[0] --> our value
    // args[1] --> value of the flag
    onEnter: function(args) {

        var userInput =  Memory.readUtf8String(args[0]);

        // this condtion to hook the targeted strcmp only
        if (userInput.includes('1234567980')) {
            // Memory.readUtf8String and Memory.readCString the only way to read from native c func
            //send("param1 = " + Memory.readUtf8String(args[0]));
            //send("param2 = " + Memory.readUtf8String(args[1]));
            send("param1 = " + Memory.readCString(args[0]));
            send("param2 = " + Memory.readCString(args[1]));

            isOurFunction = true;
        }
    },
    onLeave: function(ret) {
        // verifying that this is our strcmp which we are intersted in.
        if(isOurFunction) {
            send("return value " + ret.toInt32());
        }

        // setting it back to false --> otherwise all return values afterwards would be printed out.
        isOurFunction = false;
    }

})
```
#### using rlative pointer
**reverse libnative-lib based on the arch using ghidra:**
![Screenshot_6](https://github.com/user-attachments/assets/7de2f7bc-13a3-4376-9ce3-2ffdc4fe69c7)



```javascript
// 0xf2a1
var address = Module.findBaseAddress("libnative-lib.so").add(0xf2a1); 
console.log("Address: " + address);
Interceptor.attach(address, {
    onEnter: function(args) {
        console.log("Paramter 1: " + Memory.readCString(args[0])); 
        console.log("Paramter 2: " + Memory.readCString(args[1])); 
    },
    onLeave: function(retval) {
        console.log("Return value: " + retval.toInt32());
    }
 })
```


# Reverse 
#### list all classes
```javascript
Java.perform(function() {
    Java.enumerateLoadedClasses({
        onMatch: function(className) {
            console.log(className);
        },
        onComplete: function() {
            console.log("Done enumerating classes.");
        }
    });
});

```


#### list fucntions
```javascript
Java.perform(function() {
    var className = "com.example.targetClass";  // Replace with your class name
    var targetClass = Java.use(className);
    
    var methods = targetClass.class.getDeclaredMethods();
    methods.forEach(function(method) {
        console.log(method);
    });
});

```

