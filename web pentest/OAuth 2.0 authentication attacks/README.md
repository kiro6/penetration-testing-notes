
## OAuth Explain
[ OAuth and OpenID Connect by OktaDev](https://youtu.be/t18YB3xDfXI?si=FzFbXztH8VIXGt5b)


### Grant Types in OAuth
### Authorization Code Grant:
- **Use Case:** Suitable for web applications (server-side applications) where the client secret can be kept confidential.
- **Flow:**
  - The user logs in and authorizes the client.
  - The authorization server redirects the user back to the client with an authorization code.
  - The client exchanges the authorization code for an access token by making a request to the authorization serverâ€™s token endpoint, including the client secret.
- **Advantages:** Secure because the access token is never exposed to the user agent (browser) and involves a server-to-server communication using the client secret.

### Implicit Grant:
- **Use Case:** Suitable for browser-based or mobile applications where the client secret cannot be kept confidential.
- **Flow:**
  - The user logs in and authorizes the client.
  - The authorization server redirects the user back to the client with an access token OR use PKCE.
- **Advantages:** Simplifies the process by skipping the authorization code exchange step, making it faster but less secure because the access token is exposed to the user agent and potentially intercepted.

### Resource Owner Password Credentials Grant:
- **Use Case:** Suitable for trusted applications, like first-party clients or clients highly trusted by the resource owner.
- **Flow:**
  - The user provides their username and password directly to the client.
  - The client sends the credentials to the authorization server to obtain an access token.
- **Advantages:** Simplifies the process for trusted clients but is not recommended for third-party applications due to security risks of exposing credentials.

### Client Credentials Grant:
- **Use Case:** Suitable for machine-to-machine (M2M) applications, where there is no user involved, only the client.
- **Flow:**
  - The client authenticates with the authorization server using its client credentials (client ID and secret).
  - The authorization server issues an access token directly.
- **Advantages:** Simple and secure for server-to-server communication.

### Refresh Token Grant:
- **Use Case:** Used to obtain a new access token when the current one expires without requiring the user to re-authenticate.
- **Flow:**
  - The client includes the refresh token in a request to the token endpoint.
  - The authorization server validates the refresh token and issues a new access token.
- **Advantages:** Enhances user experience by allowing long-lived sessions without frequent re-authentication.

### Device Code Grant (Device Flow):
- **Use Case:** Suitable for devices with limited input capabilities (e.g., smart TVs, IoT devices).
- **Flow:**
  - The device requests a device code from the authorization server.
  - The user is instructed to visit a verification URL and enter the device code.
  - Once the user authorizes the device, the authorization server issues an access token to the device.
- **Advantages:** Provides a user-friendly way to authorize devices with limited input capabilities.

### PKCE
is used to protect the authorization token from being used by attacker , it uses code challenge and code verifier (hash value of code challenge) which used once per auth request 

#### **so why if the client can store the code verfier securly why does it not store the client secret securly ?**
Client Secret:
  - Lifetime: Long-lived and used across multiple authorization flows.
  - Usage: Used to authenticate the client itself.
  - Security Requirement: Must be kept confidential and secure for the entire lifetime of the client application.



Code Verifier:
  - Lifetime: Short-lived, specific to a single authorization request.
  - Usage: Used only once to exchange the authorization code for an access token.
  - Security Requirement: Needs to be kept confidential only for a short period, during the specific authorization flow.

#### code challenge is sent with first Authorization Request when we get the authorization token we send it with the code verifier to get the access token (because if the attacker intercpted the authorization token he do not know the code challenge )
